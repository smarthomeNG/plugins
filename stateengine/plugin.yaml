# Metadata for the StateEngine plugin
plugin:
    # Global plugin attributes
    type: system
    description:
        de: 'Zustandsautomat für SmarthomeNG, ehemals AutoBlind'
        en: 'Finite state machine for SmarthomeNG, previously known as AutoBlind'
    description_long:
        de: 'Der ursprüngliche Zweck dieses Plugins war es, Jalousien zu
             steuern. Mit den steigenden Anforderungen hat es sich jedoch zu
             einem flexiblen Zustandsautomaten entwickelt, mit dem nahezu alles
             gesteuert werden kann. Im Prinzip ist es ein `endlicher
             Automat <https://de.wikipedia.org/wiki/Endlicher_Automat>`_.
             Dabei arbeitet das Plugin nicht mit Events, die zu konkreten Zuständen
             führen, sondern mit einer hierarchischen Evaluierung der Zustände.
             '
        en: 'Initially this plugin was used to automatically control blinds.
             Meanwhile it is a flexible fully featured `finite state machine
             <https://en.wikipedia.org/wiki/Finite-state_machine>`_. It does not
             work with typical events to define which state is evaluated next but
             with hierarchical states.
            '
    requirements:
        de: 'pydotplus python Modul, graphviz'
        en: 'pydotplus python module, graphviz'
    requirements_long:
        de: 'Das Plugin benötigt die folgende Software, um die State Engine im Webinterface visuell darzustellen:\n
             \n
             - graphviz: ``sudo apt install graphviz``\n
             - Python Modul pydotplus: ``pip3 install pydotplus``\n
             '
        en: 'This plugin needs the following software to be installed to visualize the State Engine in the web interface:\n
             \n
             - graphviz: ``sudo apt install graphviz``\n
             - Python Modul pydotplus: ``pip3 install pydotplus``\n
             '
    maintainer: onkelandy
    tester: 'Morg42'
    state: ready
    support: https://knx-user-forum.de/forum/supportforen/smarthome-py/1303071-stateengine-plugin-support

    version: '2.2.0'
    sh_minversion: '1.6'
    multi_instance: False
    classname: StateEngine
    restartable: unknown
    attribute_prefix: se

parameters:
    # Definition of parameters to be configured in etc/plugin.yaml
    startup_delay_default:
        type: int
        default: 10
        valid_min: -1
        valid_max: 600
        description:
            de: 'Vorgabe für Verzögerung der ersten Zustandsermittlung beim Start'
            en: 'Default delay for first state determination at startup'
        description_long:
            de: '**Vorgabewert für die Startverzögerung der ersten Zustandsermittlung beim Start von smarthomeNG:**\n
                Beim Starten von smarthomeNG dauert es üblicherweise einige
                Sekunden, bis alle Items initialisiert sind. Um zu verhindern,
                dass die erste Zustandsermittlung stattfindet, bevor alle Items
                ihren Initialwert haben, wird die erste Zustandsermittlung
                verzögert. Die Dauer der Verzögerung kann bei den Objekt-Items
                angegeben werden. Wenn bei einem Objekt-Item kein Wert angegeben
                ist, wird der hier angegebene Standardwert verwendet.\n
                \n
                - Zahl größer 0:
                Angabe der Startverzögerung in Sekunden. Während der
                Startverzögerung sind die Auslöser der Zustandsermittlung
                inaktiv.\n
                - 0:
                Keine Startverzögerung. Die erste Zustandsermittlung wird direkt
                nach der Initialisierung des Objekt-Items durchgeführt.\n
                - -1:
                Es wird keine erste Zustandsermittlung durchgeführt.\n
                \n
                Ohne Angabe dieses Parameters wird der Standardwert von 10 Sekunden angenommen.
                '
            en: '**Default delay for first state determination at startup:**\n
                At smarthome startup some items might not be initialized correctly.
                To avoid a wrong state evaluation the evaluation can be postponed by the
                given amount of seconds.
                \n
                - digit higher than 0: start delay in seconds\n
                - 0: no start delay, immediate init\n
                - -1: no init\n
                \n
                '

    suspend_time_default:
        type: int
        default: 3600
        valid_min: 1
        valid_max: 86400
        description:
            de: 'Vorgabezeit zur Unterbrechung der automatischen Steuerung nach manuellen Aktionen'
            en: 'Default suspend duration after manual actions'
        description_long:
            de: '**Vorgabezeit zur Unterbrechung der automatischen Steuerung nach manuellen Aktionen:**\n
                 Nach manuellen Aktionen kann die Automatik für eine bestimmte Zeit
                 Unterbrochen werden. Die Dauer dieser Unterbrechungen kann bei den
                 Objekt-Items angegeben werden. Die Einheit für den Wert sind
                 Sekunden. Wenn bei einem Objekt-Item kein Wert angegeben ist, wird
                 der hier angegebene Standardwert verwendet. Wenn kein abweichender
                 Standardwert in der Plugin-Konfiguration angegeben ist, ist der
                 Vorgabewert 3600 Sekunden (1 Stunde)
                 '
            en: '**Default suspend duration after manual actions**:
                After a manual change of the item the automatic evaluation is paused.
                This value defines the duration of the pause in seconds if the
                value is not defined in the object item itself.
                '

    log_level:
        type: int
        default: 0
        valid_list:
          - -1
          - 0
          - 1
          - 2
          - 3
        valid_list_description:
            de: ['Standardlevel aus plugin.yaml', 'deaktiviert', 'Info', 'Debug', 'Develop']
            en: ['default level from plugin.yaml', 'deactivated', 'Info', 'Debug', 'Develop']
        description:
            de: 'Erweiterte Protokollierung: Loglevel (-1: Wert aus plugin.yaml, 0: aus, 1: Info, 2: Debug, 3: Develop/Verbose)'
            en: 'Extended Logging: Loglevel (-1: value from plugin.yaml, 0: off, 1: Info, 2: Debug, 3: Develop/Verbose)'
        description_long:
            de: '**Erweiterte Protokollierung:**\n
                 Bei einem Wert von 1, 2 oder 3 wird pro Item eine eigene Logdatei im unter log_directory
                 angegebenen Verzeichnis angelegt.
                 Wenn der Parameter nicht angegeben oder auf 0 gestellt ist,
                 ist die erweiterte Protokollierung deaktiviert.
                 '
            en: '**Extended Logging**:\n
                If 1, 2 or 3 is given  there will be a seperate log file for each item in the folder
                defined as log_directory.
                If the parameter is absent or set to 0 no extended logging is active
                '

    startup_log_level:
        type: int
        default: 2
        valid_list:
          - -1
          - 0
          - 1
          - 2
          - 3
        valid_list_description:
            de: ['Standardlevel aus plugin.yaml', 'deaktiviert', 'Info', 'Debug', 'Develop']
            en: ['default level from plugin.yaml', 'deactivated', 'Info', 'Debug', 'Develop']
        description:
            de: 'Erweiterte Protokollierung beim Starten des Plugins: Loglevel (-1: Wert aus plugin.yaml, 0: aus, 1: Info, 2: Debug, 3: Develop/Verbose)'
            en: 'Extended Logging at plugin startup: Loglevel (-1: value from plugin.yaml, 0: off, 1: Info, 2: Debug, 3: Develop/Verbose)'
        description_long:
            de: '**Erweiterte Protokollierung:**\n
                 Bei einem Wert von 1, 2 oder 3 wird pro Item eine eigene Logdatei im unter log_directory
                 angegebenen Verzeichnis angelegt.
                 Ist die Initialisierung eines Stateengine Items abgeschlossen, wird der über se_log_level oder
                 den Standard Loglevel im plugin.yaml eingestellt.
                 '
            en: '**Extended Logging**:\n
                If 1, 2 or 3 is given  there will be a seperate log file for each item in the folder
                defined as log_directory.
                After initialization of the stateengine items the log level will be set to the one
                defined in se_log_level or as a standard log level in plugin.yaml.
                '

    log_directory:
        type: str
        default: 'var/log/stateengine/'
        description:
            de: 'Erweiterte Protokollierung: Verzeichnis für die Protokolldateien'
            en: 'Extended Logging: Directory for log files'
        description_long:
            de: '**Verzeichnis für die Protokolldateien:**\n
                 Die Logdateien der erweiterten Protokollierung werden in das
                 hier angegebene Verzeichnis geschrieben.\n
                 Wenn der angegebene Verzeichnisname mit "/" beginnt wird er als
                 absoluter Verzeichnisname behandelt. Alle anderen
                 Verzeichnisnamen werden als Unterverzeichnisse des smarthomeNG
                 Basisverzeichnisses behandelt. Das angegebene Verzeichnis wird
                 angelegt, wenn es nicht existiert.\n
                 Wenn hier kein abweichendes Verzeichnis angegeben ist, wird das
                 Verzeichnis ``<smarthome_base_directory>/var/log/stateengine/``
                 verwendet.
                 '
            en: '**Directory for log files**:\n
                The extended log files are saved in the directory defined with
                this parameter.\n
                If the folder name starts with a "/" it is
                interpreted as an absolut path, otherwise relative to the smarthomeNG
                base folder. The folder is created on the first plugin start if
                it does not exist.\n
                If the parameter is absent the log files will be saved to
                ``<smarthome_base_directory>/var/log/stateengine/``
                '
    log_maxage:
        type: int
        valid_min: 0
        default: 0
        description:
            de: 'Erweiterte Protokollierung: Anzahl der Tage, nach der die Dateien im Verzeichnis für die Protokolldateien wieder gelöscht werden sollen'
            en: 'Extended Logging: Number of days after which the files in the directory for log files should be deleted'
        description_long:
            de: '**Log Rotation für erweiterte Protokollierung:**\n
                 Alte Protokolldateien können nach einer bestimmten Zeit
                 automatisch gelöscht werden. Durch diesen Parameter wird die Anzahl
                 der Tage festgelegt, nach der die Dateien gelöscht werden sollen.
                 Das Löschen ist ausgesetzt, solange der Parameter den Wert 0 hat.
                 Wenn der Parameter auf einen anderen Wert gesetzt wird, wird das
                 Alter der Dateien im Protokollverzeichnis ``log_directory``
                 täglich geprüft und überalterte Dateien werden gelöscht.\n
                 \n
                 **Achtung:**\n
                 Die Löschfunktionalität prüft und löscht alle
                 Dateien im Protokollverzeichnis, ob sie Protokolldateien sind
                 oder nicht. Daher sollten keine anderen Dateien in diesem
                 Verzeichnis abgelegt werden!
                 '
            en: '**Log rotation for extended logging:**\n
                If this parameter is not set to 0 older log files get deleted after
                the given amount of days from the ``log_directory``.\n
                \n
                **Warning:**\n
                Everything gets deleted from the given directory, not just log files!
                '

    lamella_open_value:
        type: num
        default: 0
        valid_min: 0
        valid_max: 100
        description:
            de: 'Je nach Lamellenart muss für die sun_tracking() Funktion die sonnenstandsbezogene Berechnung
                der Lamellenausrichtung angepasst werden.
                Hier ist der Prozentwert der Lamellen im komplett waagrechten Zustand anzugeben.'
            en: 'Depending on the lamella variant it might be necessary to adapt the calculation of the lamella
                orientation for a correct sun_tracking() function.
                This value defines the complete open, horizontal lamella state in percent.'
        description_long:
            de: 'Je nach Lamellenart muss die sonnenstandsbezogene Berechnung der Lamellenausrichtung angepasst werden.
                Für z-Lamellen kann hier der standardmäßige Wert 0 gewählt werden, hat man jedoch normale Lamellen,
                die sich nach oben und unten drehen, werden die Lamellen in der Regel bei 50% komplett offen, also
                waagrecht stehen. Somit sollte hier der Wert 50 angegeben werden, um eine korrekte Ausrichtung beim
                Nutzen der sun_tracking Funktion zu gewährleisten.'
            en: 'Depending on the lamella variant it might be necessary to adapt the calculation of the lamella orientation.
                If you have z-lamella you can use the standard value 0. But if you have normal lamella that can turn up
                or down, the lamella are most likely fully open at 50%. In this case you have to set this parameter
                to 50 to have a correct orientation using the sun_tracking() function.'

    lamella_offset:
        type: num
        default: 0
        valid_min: -90
        valid_max: 90
        description:
            de: 'Gibt es ein Problem mit dem automatischen Ausrichten der Lamellen mittels sun_tracking Funktion,
                kann ein globaler Offset eingestellt werden, der für alle Aufrufe besagter Funktion berücksichtigt wird.'
            en: 'If there is a problem with the automatic orientation of lamellas using the sun_tracking function,
                a global offset can be defined that is used for all instances of the aforementioned function.'

    instant_leaveaction:
        type: bool
        default: False
        description:
            de: 'Ist dieser Parameter auf True gesetzt, werden "on leave" Aktionen sofort ausgeführt,
                wenn der aktuelle Zustand nicht mehr eingenommen wird. Standardmäßig werden die Aktionen erst direkt
                vor dem Eintreten in einen neuen Zustand getriggert.'
            en: 'If this parameter is set to True the "on leave" actions are run immediately after not entering the
                current state again. By default the actions are triggered directly before entering a new state.'

item_attributes:
    # Definition of item attributes defined by this plugin (enter 'item_attributes: NONE', if section should be empty)
    type:
        type: str
        valid_list:
          - 'bool'
        valid_list_description:
            de: ['Der Item Typ muss auf bool gestellt werden!']
            en: ['The item type has to be set to bool']
        description:
            de: 'Datentyp des Objekt-Items. Muss "bool" sein.'
            en: 'Data type of the object item. Has to be "bool"'

    se_instant_leaveaction:
        type: foo
        default: False
        description:
            de: 'Ist dieser Parameter auf True bzw. 1 gesetzt, werden "on leave" Aktionen
                sofort ausgeführt, wenn der aktuelle Zustand nicht mehr eingenommen wird.
                Standardmäßig werden die Aktionen erst direkt vor dem Eintreten in
                einen neuen Zustand getriggert. Kann auch über ein Item zur Laufzeit geändert werden,
                beispielsweise durch item:..settings.instant_leaveaction. Der Wert -1 sorgt dafür,
                dass der in der plugin.yaml angegebene Standardwert herangezogen wird.
                '
            en: 'If this parameter is set to True or 1 the "on leave" actions are run
                immediately after not entering the current state
                again. By default the actions are triggered directly before
                entering a new state. Can also be defined by a valid item,
                e.g. item:..settings.instant_leaveaction. By setting the value to -1
                the default value from the plugin.yaml file is used.
                '

    se_plugin:
        type: str
        mandatory: True
        valid_list:
          - 'active'
          - 'inactive'
        valid_list_description:
            de: ['Aktiviert die State Machine', 'Jeder andere Wert deaktiviert die State Machine']
            en: ['Activates the state machine', 'Any other value deactivates the state machine']
        description:
            de: 'Kennzeichnet das Item als Objekt-Item des StateEngine-Plugins. Ist der Wert nicht "active", werden keine Zustände evaluiert.'
            en: 'Makes the StateEngine-Plugin aware of this item as an object item. If the value is not "active", the state are not evaluated.'

    se_startup_delay:
        type: int
        valid_min: -1
        valid_max: 600
        description:
            de: 'Vorgabe für Verzögerung der ersten Zustandsermittlung beim Start'
            en: 'Default delay for first state determination at startup'
        description_long:
            de: '**Startverzögerung der ersten Zustandsermittlung beim Start von smarthomeNG:**\n
                Beim Starten von smarthomeNG dauert es üblicherweise einige
                Sekunden, bis alle Items initialisiert sind. Um zu verhindern,
                dass die erste Zustandsermittlung stattfindet, bevor alle Items
                ihren Initialwert haben, wird die erste Zustandsermittlung
                verzögert. Zustandsermittlungen, die durch Items oder Timer vor Ablauf der
                Startverzögerung ausgelöst werden, werden nicht durchgeführt.
                Die zulässigen Werte für ``se_startup_delay`` sind identisch
                mit den zulässigen Werten für den Plugin-Parameter
                ``startup_delay_default``.
                '
            en: '**Delay for first state determination at startup:**\n
                 All evaluations are suspended until the startup delay has passed.
                 The values for ``se_startup_delay`` are the same as for the plugin
                 parameter ``startup_delay_default``.
                 '

    se_name:
        type: str
        description:
            de: 'Zustandsname, überschreibt den im Attribut "name" angegebene Wert'
            en: 'Name of state, overwriting the value defined by "name" attribute'
        description_long:
            de: '**Zustandsname, überschreibt den im Attribut "name" angegebene Wert**\n
                Dies kann beispielsweise nützlich sein, um den Namen abhängig
                von einer Bedingungsgruppe zu ändern.
                '
            en: '**Name of state, overwriting the value defined by "name" attribute**\n
                 Could be useful to change the state name based on a condition group
                 '

    se_laststate_item_name:
        type: str
        description:
            de: 'Id des Items, in dem der Name des aktuellen Zustands abgelegt wird'
            en: 'Id of the item that saves the name of the current state'
        description_long:
            de: '**Id des Items, in dem der Name des aktuellen Zustands abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des aktuellen Zustands
                abgelegt. Das Item kann für Displayzwecke und Bedingungen verwendet werden.
                '
            en: '**Id of the item that saves the name of the current state:**\n
                 The item defined here saves the name of the current state for
                 visualization purposes and conditions.
                 '

    se_laststate_item_id:
        type: str
        description:
            de: 'Id des Items, in dem die ID des aktuellen Zustands abgelegt wird'
            en: 'Id of the item that saves the ID of the current state'
        description_long:
            de: '**Id des Items, in dem der aktuelle Zustand abgelegt wird:**\n
                In das hier verknüpfte Item wird die Id des aktuellen Zustands
                abgelegt. Das Item kann mit dem Attribut ``cache: yes``
                versehen werden, dann bleibt der vorherige Zustand bei einem
                Neustart von smarthomeNG erhalten.
                '
            en: '**Id of the item that saves the id of the current state:**\n
                 In combination with the attribute ``cache: yes`` the defined item
                 can be used to load the last state after the plugin start.
                 '
    se_lastconditionset_item_name:
        type: str
        description:
            de: 'Name des Items, in dem der Name des zuletzt genutzten Zustandsets abgelegt wird'
            en: 'Name of the item that saves the name of the last used condition set'
        description_long:
            de: '**Name des Items, in dem der Name des aktuellen Zustandsets abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des zuletzt aktiven Zustandsets
                abgelegt. Das Item kann für Displayzwecke, Aktionen und Bedingungen genutzt werden.
                '
            en: '**Name of the item that saves the name of the last condition set:**\n
                 The item defined here saves the name of the last active condition set.
                 It can be used for visualization, actions and conditions.
                 '

    se_lastconditionset_item_id:
        type: str
        description:
            de: 'ID des Items, in dem der Name des zuletzt genutzten Zustandsets abgelegt wird'
            en: 'ID of the item that saves the name of the last used condition set'
        description_long:
            de: '**ID des Items, in dem der Name des aktuellen Zustandsets abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des zuletzt aktiven Zustandsets
                abgelegt. Das Item kann für Displayzwecke, Aktionen und Bedingungen genutzt werden.
                '
            en: '**ID of the item that saves the name of the last condition set:**\n
                 The item defined here saves the name of the last active condition set.
                 It can be used for visualization, actions and conditions.
                 '

    se_previousstate_item_name:
        type: str
        description:
            de: 'Id des Items, in dem der Name des vorherigen Zustands abgelegt wird'
            en: 'Id of the item that saves the name of the previous state'
        description_long:
            de: '**Id des Items, in dem der Name des vorherigen Zustands abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des vorigen Zustands
                abgelegt. Das Item kann für Displayzwecke und Bedingungen verwendet werden.
                '
            en: '**Id of the item that saves the name of the previous state:**\n
                 The item defined here saves the name of the previous state for
                 visualization purposes and conditions.
                 '

    se_previousstate_item_id:
        type: str
        description:
            de: 'Id des Items, in dem die ID des vorherigen Zustands abgelegt wird'
            en: 'Id of the item that saves the ID of the previous state'
        description_long:
            de: '**Id des Items, in dem der vorherige Zustand abgelegt wird:**\n
                In das hier verknüpfte Item wird die Id des vorherigen Zustands
                abgelegt. Das Item kann mit dem Attribut ``cache: yes``
                versehen werden, dann bleibt der vor-vorherige Zustand bei einem
                Neustart von smarthomeNG erhalten.
                '
            en: '**Id of the item that saves the id of the previous state:**\n
                 In combination with the attribute ``cache: yes`` the defined item
                 can be used to load the previous state after the plugin start.
                 '
    se_previousconditionset_item_name:
        type: str
        description:
            de: 'Name des Items, in dem der Name des vorherigen Zustandsets abgelegt wird'
            en: 'Name of the item that saves the name of the previously used condition set'
        description_long:
            de: '**Name des Items, in dem der Name des vorherigen Zustandsets abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des vorherigen Zustandsets
                abgelegt. Das Item kann für Displayzwecke, Aktionen und Bedingungen genutzt werden.
                '
            en: '**Name of the item that saves the name of the previous condition set:**\n
                 The item defined here saves the name of the previously active condition set.
                 It can be used for visualization, actions and conditions.
                 '

    se_previousconditionset_item_id:
        type: str
        description:
            de: 'ID des Items, in dem der Name des vorherigen Zustandsets abgelegt wird'
            en: 'ID of the item that saves the name of the previously used condition set'
        description_long:
            de: '**ID des Items, in dem der Name des vorherigen Zustandsets abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des vorherigen Zustandsets
                abgelegt. Das Item kann für Displayzwecke, Aktionen und Bedingungen genutzt werden.
                '
            en: '**ID of the item that saves the name of the previous condition set:**\n
                 The item defined here saves the name of the previously active condition set.
                 It can be used for visualization, actions and conditions.
                 '

    se_previousstate_conditionset_item_name:
        type: str
        description:
            de: 'Name des Items, in dem der Name des Zustandsets vom vorigen Zustand abgelegt wird'
            en: 'Name of the item that saves the name of the previous state condition set'
        description_long:
            de: '**Name des Items, in dem der Name des Zustandsets vom vorherigen Zustand abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des Zustandssets des vorherigen Zustands
                abgelegt. Das Item kann für Displayzwecke, Aktionen und Bedingungen genutzt werden.
                '
            en: '**Name of the item that saves the name of the condition set of the previous state:**\n
                 The item defined here saves the name of the previous state condition set.
                 It can be used for visualization, actions and conditions.
                 '

    se_previousstate_conditionset_item_id:
        type: str
        description:
            de: 'ID des Items, in dem der Name des Zustandsets vom vorigen Zustand abgelegt wird'
            en: 'ID of the item that saves the name of the previous state condition set'
        description_long:
            de: '**ID des Items, in dem der Name des Zustandsets vom vorherigen Zustand abgelegt wird:**\n
                In das hier verknüpfte Item wird der Name des Zustandssets des vorherigen Zustands
                abgelegt. Das Item kann für Displayzwecke, Aktionen und Bedingungen genutzt werden.
                '
            en: '**ID of the item that saves the name of the condition set of the previous state:**\n
                 The item defined here saves the name of the previous state condition set.
                 It can be used for visualization, actions and conditions.
                 '

    se_repeat_actions:
        type: bool
        description:
            de: 'Wiederholen der Aktionen bei unverändertem Zustand'
            en: 'Repeat actions on eval even if the state stays the same'
        description_long:
            de: '**Wiederholen der Aktionen bei unverändertem Zustand:**\n
                Im Normalfall werden Aktionen jedesmal ausgeführt wenn der
                aktuelle Zustand neu ermittelt wurde. Dies ist unabhängig davon,
                ob sich der Zustand bei der Neuermittlung geändert hat oder nicht.
                Durch die Angabe von ``se_repeat_actions: false`` werden die Aktionen
                nur beim erstmaligen Aktivieren des Zustands ausgeführt. Diese Option
                ist auch für jede Aktion separat verfügbar, um vom hier angegebenen
                Wert abzuweichen.
                '
            en: '**Repeat actions on eval even if the state stays the same:**\n
                 Generally actions are executed every time a state is entered, even if
                 the state does not change. By setting ``se_repeat_actions: false``
                 the actions are exclusively when entering the first state the first time.
                 This option is also available for every action seperately to overrule this setting.
                 '

    se_suspend_time:
        type: foo
        valid_min: -60
        valid_max: 86400
        description:
            de: 'Dauer der Unterbrechung der automatischen Steuerung nach manuellen Aktionen in Sekunden'
            en: 'Suspend duration after manual actions in seconds'
        description_long:
            de: '**Unterbrechung der automatischen Steuerung nach manuellen Aktionen:**\n
                 Nach manuellen Aktionen kann die Automatik für eine bestimmte Zeit
                 Unterbrochen werden. Wird die Dauer nicht im Objekt-Item definiert,
                 wird die Standarddauer aus der Plugin Konfiguration oder der Standardwert
                 von 3600 Sekunden (1 Stunde) angenommen.
                 '
            en: '**Suspend duration after manual actions**:
                After a manual change of the item the automatic evaluation is paused.
                If this value is not defined in the object item, the default value
                from the plugin configuration or the default value of 3600 seconds (1 hour)
                is used.
                '

    se_stateorder:
        type: foo
        valid_min: 1
        description:
            de: 'Position des Zustands bezüglich der Evaluierungsabfolge'
            en: 'Position of the state regarding the evaluation order'
        description_long:
            de: 'Durch diesen Wert wird bestimmt, an welcher Position der Status eingeordnet wird.
                 Normalerweise ist die Sortierung abhängig von der Angabe der Stati innerhalb des
                 rules Items. Durch diesen Wert kann die Sortierung zur Laufzeit abgeändert werden.
                 Der Wert kann als Zahl, item oder eval deklariert werden.
                 '
            en: 'This value determines the position at which the status is sorted.
                 Normally, the sorting depends on the specification of the statuses within the
                 rules item. This value can be used to change the sorting at runtime.
                 The value can be declared as an int number, item or eval expression.
                '

    se_item_suspend_end:
        type: str
        description:
            de: 'Id des Items, in dem das Ende der Suspendzeit abgelegt werden soll'
            en: 'Id of the item that saves the suspend end time'
        description_long:
            de: '**Id des Items, in dem das Ende der Suspendzeit abgelegt werden soll:**\n
                Für Visualisierungszwecke kann der Inhalt des hier verknüpften Items
                angezeigt werden. Dadurch ist ersichtlich, bis wann die Statusevaluierung
                noch ausgesetzt wird.
                '
            en: '**Id of the item that saves the suspend end time:**\n
                To visualize the end time of the suspend state.
                '

    se_item_suspend_start:
        type: str
        description:
            de: 'Id des Items, in dem der Start der Suspendzeit abgelegt werden soll'
            en: 'Id of the item that saves the suspend start time'
        description_long:
            de: '**Id des Items, in dem der Start der Suspendzeit abgelegt werden soll:**\n
                Für Visualisierungszwecke kann der Inhalt des hier verknüpften Items
                z.B. im clock.countdown Widget der SmartVisu genutzt werden.
                '
            en: '**Id of the item that saves the suspend start time:**\n
                To visualize the start time of the suspend state can be used
                for example for the clock.countdown widget.
                '

    se_log_level:
        type: foo
        description:
            de: 'Loglevel für ein konkretes Stateengine Item'
            en: 'Log level for a distinct stateengine item'
        description_long:
            de: 'Das global angegebene Loglevel kann für jedes SE item individuell überschrieben werden.
                 Somit ist es einfacher möglich, bestimme State Engines zu debuggen.
                 Das Loglevel kann durch das Settings Item log_level im laufenden Betrieb angepasst werden.
                 Ist der Wert auf -1 gesetzt, wird der Standardwert aus dem plugin.yaml übernommen.
                '
            en: 'The globally defined log level can be overwritten for each SE item individually.
                 Therefore it is easier to debug specific state engines.
                 The log level can be adjusted by changing the setting item log_level while the plugin is running.
                 If the value is set to -1 the standard value from plugin.yaml is used.
                '

    se_use:
        type: list(str)
        description:
            de: 'Nutzen eines Vorgabezustands'
            en: 'Using a default template'
        description_long:
            de: 'Vorgabezustände werden als Item an beliebiger Stelle innerhalb der
                Item-Struktur definiert. Im konkreten Zustands-Item kann das Vorgabezustand-Item
                oder ein beliebiges struct über das Attribut se_use referenziert werden. Die zu
                nützenden Templates können auch über die **eval:** Deklaration zu Beginn des Werts
                unter Einbezug eines validen Eval-Ausdrucks dynamisch zur Laufzeit gesetzt werden.
                '
            en: 'Template states are defined as an item at any given position in the item tree.
                In the specific state item the template or any struct can get referenced by using the attribute
                se_use. The templates that should be used can even be dynamically changed during runtime
                by using the **eval:** declaration in front of a valid eval expression
                '

    se_released_by:
        type: list(str)
        description:
            de: 'Definieren von untergeordneten Zuständen, die den aktuellen Zustand auflösen können'
            en: 'Definition of subordinate states that can release the current state'
        description_long:
            de: 'Durch Setzen dieses Attributs können Zustände durch untergeordnete Zustände aufgelöst
                 werden. Sobald ein durch das Attribut definierter untergeordneter Zustand neu
                 eingenommen werden könnte, wird der aktuelle Zustand verlassen und eine neue
                 Zustandsevaluierung ausgeführt.
                '
            en: 'By setting this attribute, states can be resolved by subordinate states.
                 As soon as a subordinate state defined by the attribute could be newly
                 entered by the attribute, the current state is left and a new state evaluation is performed.
                '

item_structs:
    # Definition of item-structure templates for this plugin (enter 'item_structs: NONE', if section should be empty)
    general:
        name: Vorlage-Struktur für einen Zustandsautomaten

        state_id:
            remark: The id/path of the actual state is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        state_name:
            remark: The name of the actual state is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        conditionset_id:
            remark: The id/path of the actual condition set is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        conditionset_name:
            remark: The name of the actual condition set is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        previousconditionset_id:
            remark: The id/path of the previous condition set is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        previousconditionset_name:
            remark: The name of the previous condition set is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        previousstate_id:
            remark: The id/path of the previous state is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        previousstate_name:
            remark: The name of the previous state is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        previousstate_conditionset_id:
            remark: The id/path of the condition set of the previous state is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        previousstate_conditionset_name:
            remark: The name of the condition set of the previous state is assigned to this item by the stateengine
            type: str
            visu_acl: ro
            cache: True

        retrigger:
            remark: Item to retrigger the rule set evaluation
            type: bool
            visu_acl: rw
            enforce_updates: True
            on_update: ..rules = True if value is True else None
            autotimer: 1 = False

        settings:
            log_level:
              type: num
              cache: True
              initial_value: -1

            instant_leaveaction:
              type: num
              cache: True
              initial_value: -1

        rules:
            name: Zustandsautomat
            remark: configure your se_item_* and eval_triggers here
            type: bool
            se_plugin: active
            se_log_level: item:..settings.log_level
            se_instant_leaveaction: item:..settings.instant_leaveaction
            eval: True
            se_laststate_item_id: ..state_id
            se_laststate_item_name: ..state_name
            se_lastconditionset_item_id: ..conditionset_id
            se_lastconditionset_item_name: ..conditionset_name
            se_previousconditionset_item_id: ..previousconditionset_id
            se_previousconditionset_item_name: ..previousconditionset_name
            se_previousstate_item_id: ..previousstate_id
            se_previousstate_item_name: ..previousstate_name
            se_previousstate_conditionset_item_id: ..previousstate_conditionset_id
            se_previousstate_conditionset_item_name: ..previousstate_conditionset_name

    state_lock:
        name: Zustandsvorlage zum Sperren der Evaluierung

        lock:
            type: bool
            knx_dpt: 1
            visu_acl: rw
            cache: 'on'

        rules:
            se_item_lock: ..lock
            eval_trigger:
                - ..lock

            lock:
                name: gesperrt

                enter:
                    se_value_lock: True

    state_suspend:
        name: Zustandsvorlage für manuelles Aussetzen

        suspend:
            type: bool
            knx_dpt: 1
            visu_acl: rw
            cache: True

            visu:
                type: bool
                knx_dpt: 1
                visu_acl: rw
                cache: True

        suspend_end:
            type: str
            visu_acl: ro
            eval: "'' if not any(char.isdigit() for char in sh..self.date_time()) else sh..self.date_time().split(' ')[1].split('.')[0]"
            eval_trigger: .date_time
            crontab: init

            date_time:
                type: str
                visu_acl: ro
                cache: True

            unix_timestamp:
                type: num
                visu_acl: ro
                eval: "0 if not any(char.isdigit() for char in sh...date_time()) else  shtime.datetime_transform(sh...date_time()).timestamp() * 1000"
                eval_trigger: ..date_time
                crontab: init

        suspend_start:
            type: str
            visu_acl: ro
            eval: "'' if not any(char.isdigit() for char in sh..self.date_time()) else sh..self.date_time().split(' ')[1].split('.')[0]"
            eval_trigger: .date_time
            crontab: init

            date_time:
                type: str
                visu_acl: ro
                cache: True

            unix_timestamp:
                remark: Can be used for the clock.countdown widget
                type: num
                visu_acl: ro
                eval: "0 if not any(char.isdigit() for char in sh...date_time()) else  shtime.datetime_transform(sh...date_time()).timestamp() * 1000"
                eval_trigger: ..date_time
                crontab: init

        manuell:
            type: bool
            name: manuell
            se_manual_invert: True
            remark: Adapt the se_manual_exclude the way you need it
            #se_manual_include: KNX:* Force manual mode based on source
            se_manual_exclude:
              - database:.*
              - init:.*

        retrigger:
            remark: Item to retrigger the rule set evaluation
            type: bool
            visu_acl: rw
            enforce_updates: True
            on_update: ..rules = True if value is True else None
            autotimer: 1 = False

        settings:
            remark: Use these settings for your condition values
            type: bool
            eval: sh..suspendduration(sh..suspendduration(), "Init", "Start")
            crontab: init = True

            conditionset_leaveactions:
                suspend:
                    type: str
                    initial_value: '.*'
                    cache: True

            suspendduration:
                remark: duration of suspend mode in minutes (gets converted automatically)
                type: num
                visu_acl: rw
                cache: True
                enforce_updates: True
                initial_value: 60
                on_change: .seconds = value * 60 if not sh..self.property.last_change_by in ["On_Change:{}".format(sh..seconds.property.path), "On_Change:{}".format(sh..duration_format.property.path)] else None
                on_update: .seconds = value * 60 if "Init" in sh..self.property.last_update_by else None

                duration_format:
                    remark: Can be used for the clock.countdown widget and smartvisu
                    type: str
                    cache: True
                    visu_acl: rw
                    on_change: ..seconds = sum([a*b for a,b in zip([216000,3600,60,1], map(int,value.replace('d','').replace('h','').replace('i','').replace('s','').split(' ')))]) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...seconds.property.path), "On_Update:{}".format(sh...seconds.property.path)] else None

                seconds:
                    remark: duration of suspend mode in seconds (gets converted automatically)
                    type: num
                    visu_acl: rw
                    cache: True
                    on_change:
                      - .. = value / 60 if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh....property.path), "On_Update:{}".format(sh....property.path)] else None
                      - ..duration_format = '{}d {}h {}i {}s'.format(int(value//86400), int((value%86400)//3600), int((value%3600)//60), round((value%3600)%60)) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...duration_format.property.path), "On_Update:{}".format(sh...duration_format.property.path)] else None

            suspend_active:
                remark: Use this to (de)activate suspend mode in general
                type: bool
                visu_acl: rw
                cache: True
                initial_value: True

            settings_edited:
                type: bool
                name: settings editiert
                eval_trigger: ...settings.*
                eval: not sh..self()
                on_update: ...retrigger = True if sh..self.property.prev_update_age > 0.1 else None

        rules:
            se_item_suspend: ..suspend
            se_item_suspend_visu: ..suspend.visu
            se_item_suspend_end: ..suspend_end.date_time
            se_item_suspend_start: ..suspend_start.date_time
            se_item_suspend_active: ..settings.suspend_active
            se_suspend_time: item:..settings.suspendduration.seconds

            eval_trigger:
                - ..manuell

            suspend:
                name: ausgesetzt

                on_enter:
                    se_action_suspend_visu:
                      - 'function: set'
                      - 'to: True'
                      - 'order: 2'

                on_enter_or_stay:
                    se_action_suspend:
                      - 'function: special'
                      - 'value: suspend:..suspend, ..manuell'
                      - 'repeat: True'
                      - 'order: 1'
                    se_action_suspend_end:
                      - 'function: set'
                      - "to: eval:se_eval.insert_suspend_time('..suspend', suspend_text='%Y-%m-%d %H:%M:%S.%f%z')"
                      - 'repeat: True'
                      - 'order: 3'
                    se_action_suspend_start:
                      - 'function: set'
                      - "to: eval:str(shtime.now())"
                      - 'repeat: True'
                      - 'conditionset: (.*)enter_manuell'
                      - 'order: 4'
                    se_action_retrigger:
                      - 'function: special'
                      - 'value: retrigger:..retrigger'
                      - 'delay: var:item.suspend_remaining'
                      - 'repeat: True'
                      - 'order: 5'

                on_pass:
                    se_action_suspend:
                      - 'function: set'
                      - 'to: False'
                      - 'repeat: False'
                    se_action_suspend_visu:
                      - 'function: set'
                      - 'to: False'
                      - 'repeat: False'
                    se_action_suspend_end:
                      - 'function: set'
                      - 'to:  '
                      - 'repeat: False'
                    se_action_suspend_start:
                      - 'function: set'
                      - 'to:  '
                      - 'repeat: False'

                on_leave:
                    se_action_suspend:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 2'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_suspend_visu:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 3'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_suspend_end:
                      - 'function: set'
                      - 'to:  '
                      - 'order: 4'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_suspend_start:
                      - 'function: set'
                      - 'to:  '
                      - 'order: 5'
                      - 'delay: 1'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_retrigger:
                      - 'function: special'
                      - 'value: retrigger:..retrigger'
                      - 'delay: -1'
                      - 'order: 1'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'

                enter_manuell:
                    se_value_trigger_source: eval:se_eval.get_relative_itemproperty('..manuell', 'path')
                    se_value_suspend_active: True

                enter_stay:
                    se_value_laststate: var:current.state_id
                    se_agemax_suspend: var:item.suspend_time
                    se_value_suspend: True
                    se_value_suspend_active: True

    state_suspend_dynamic:
        name: Zustandsvorlage für manuelles Aussetzen mit dynamischen Parametern

        suspend:
            type: bool
            knx_dpt: 1
            visu_acl: rw
            cache: True

            visu:
                type: bool
                knx_dpt: 1
                visu_acl: rw
                cache: True

        suspend_end:
            type: str
            visu_acl: ro
            eval: "'' if not any(char.isdigit() for char in sh..self.date_time()) else sh..self.date_time().split(' ')[1].split('.')[0]"
            eval_trigger: .date_time
            crontab: init

            date_time:
                type: str
                visu_acl: ro
                cache: True

            unix_timestamp:
                type: num
                visu_acl: ro
                eval: "0 if not any(char.isdigit() for char in sh...date_time()) else  shtime.datetime_transform(sh...date_time()).timestamp() * 1000"
                eval_trigger: ..date_time
                crontab: init

        suspend_start:
            type: str
            visu_acl: ro
            eval: "'' if not any(char.isdigit() for char in sh..self.date_time()) else sh..self.date_time().split(' ')[1].split('.')[0]"
            eval_trigger: .date_time
            crontab: init

            date_time:
                type: str
                visu_acl: ro
                cache: True

            unix_timestamp:
                remark: Can be used for the clock.countdown widget
                type: num
                visu_acl: ro
                eval: "0 if not any(char.isdigit() for char in sh...date_time()) else  shtime.datetime_transform(sh...date_time()).timestamp() * 1000"
                eval_trigger: ..date_time
                crontab: init

        manuell:
            type: bool
            name: manuell
            se_manual_invert: True
            remark: Adapt the se_manual_exclude the way you need it
            #se_manual_include: KNX:* Force manual mode based on source
            se_manual_exclude:
              - database:.*
              - init:.*

        retrigger:
            remark: Item to retrigger the rule set evaluation
            type: bool
            visu_acl: rw
            enforce_updates: True
            on_update: ..rules = True if value is True else None
            autotimer: 1 = False

        settings:
            remark: Use these settings for your condition values
            type: bool
            eval: (sh..suspendduration(sh..suspendduration(), "Init", "Start"), sh..suspendvariant.suspendduration0(sh..suspendduration(), "Init", "Start"), sh..suspendvariant.suspendduration1(sh..suspendvariant.suspendduration1(), "Init", "Start"), sh..suspendvariant.suspendduration2(sh..suspendvariant.suspendduration2(), "Init", "Start"))
            crontab: init = True

            conditionset_leaveactions:
                suspend:
                    type: str
                    initial_value: '.*'
                    cache: True

            suspendvariant:
                remark: number between 0 and 2 to define which suspendduration should be used
                type: num
                visu_acl: rw
                cache: True
                initial_value: 0

                suspendduration0:
                    remark: duration of suspend mode in minutes (gets converted automatically)
                    type: num
                    visu_acl: rw
                    cache: True
                    enforce_updates: True
                    initial_value: -1
                    on_change: .seconds = value * 60 if not sh..self.property.last_change_by in ["On_Change:{}".format(sh..seconds.property.path), "On_Change:{}".format(sh..duration_format.property.path)] else None
                    on_update: .seconds = value * 60 if "Init" in sh..self.property.last_update_by else None

                    duration_format:
                        remark: Can be used for the clock.countdown widget and smartvisu
                        type: str
                        cache: True
                        visu_acl: rw
                        on_change: ..seconds = sum([a*b for a,b in zip([216000,3600,60,1], map(int,value.replace('d','').replace('h','').replace('i','').replace('s','').split(' ')))]) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...seconds.property.path), "On_Update:{}".format(sh...seconds.property.path)] else None

                    seconds:
                        remark: duration of suspend mode in seconds (gets converted automatically)
                        type: num
                        visu_acl: rw
                        cache: True
                        on_change:
                          - .. = value / 60 if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh....property.path), "On_Update:{}".format(sh....property.path)] else None
                          - ..duration_format = '{}d {}h {}i {}s'.format(int(value//86400), int((value%86400)//3600), int((value%3600)//60), round((value%3600)%60)) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...duration_format.property.path), "On_Update:{}".format(sh...duration_format.property.path)] else None

                suspendduration1:
                    remark: duration of suspend mode in minutes (gets converted automatically)
                    type: num
                    visu_acl: rw
                    cache: True
                    enforce_updates: True
                    initial_value: -1
                    on_change: .seconds = value * 60 if not sh..self.property.last_change_by in ["On_Change:{}".format(sh..seconds.property.path), "On_Change:{}".format(sh..duration_format.property.path)] else None
                    on_update: .seconds = value * 60 if "Init" in sh..self.property.last_update_by else None

                    duration_format:
                        remark: Can be used for the clock.countdown widget and smartvisu
                        type: str
                        cache: True
                        visu_acl: rw
                        on_change: ..seconds = sum([a*b for a,b in zip([216000,3600,60,1], map(int,value.replace('d','').replace('h','').replace('i','').replace('s','').split(' ')))]) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...seconds.property.path), "On_Update:{}".format(sh...seconds.property.path)] else None

                    seconds:
                        remark: duration of suspend mode in seconds (gets converted automatically)
                        type: num
                        visu_acl: rw
                        cache: True
                        on_change:
                          - .. = value / 60 if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh....property.path), "On_Update:{}".format(sh....property.path)] else None
                          - ..duration_format = '{}d {}h {}i {}s'.format(int(value//86400), int((value%86400)//3600), int((value%3600)//60), round((value%3600)%60)) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...duration_format.property.path), "On_Update:{}".format(sh...duration_format.property.path)] else None

                suspendduration2:
                    remark: duration of suspend mode in minutes (gets converted automatically)
                    type: num
                    visu_acl: rw
                    cache: True
                    enforce_updates: True
                    initial_value: -1
                    on_change: .seconds = value * 60 if not sh..self.property.last_change_by in ["On_Change:{}".format(sh..seconds.property.path), "On_Change:{}".format(sh..duration_format.property.path)] else None
                    on_update: .seconds = value * 60 if "Init" in sh..self.property.last_update_by else None

                    duration_format:
                        remark: Can be used for the clock.countdown widget and smartvisu
                        type: str
                        cache: True
                        visu_acl: rw
                        on_change: ..seconds = sum([a*b for a,b in zip([216000,3600,60,1], map(int,value.replace('d','').replace('h','').replace('i','').replace('s','').split(' ')))]) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...seconds.property.path), "On_Update:{}".format(sh...seconds.property.path)] else None

                    seconds:
                        remark: duration of suspend mode in seconds (gets converted automatically)
                        type: num
                        visu_acl: rw
                        cache: True
                        on_change:
                          - .. = value / 60 if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh....property.path), "On_Update:{}".format(sh....property.path)] else None
                          - ..duration_format = '{}d {}h {}i {}s'.format(int(value//86400), int((value%86400)//3600), int((value%3600)//60), round((value%3600)%60)) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...duration_format.property.path), "On_Update:{}".format(sh...duration_format.property.path)] else None

                additionaluse0:
                    remark: set this value to a struct or (relative) state that should be added to the condition sets if suspendvariant is 0
                    type: str
                    visu_acl: rw
                    cache: True
                    initial_value: 'struct:stateengine.state_standard.rules.standard'

                additionaluse1:
                    remark: set this value to a struct or (relative) state that should be added to the condition sets if suspendvariant is 1
                    type: str
                    visu_acl: rw
                    cache: True
                    initial_value: 'struct:stateengine.state_standard.rules.standard'

                additionaluse2:
                    remark: set this value to a struct or (relative) state that should be added to the condition sets if suspendvariant is 2
                    type: str
                    visu_acl: rw
                    cache: True
                    initial_value: 'struct:stateengine.state_standard.rules.standard'

            suspendduration:
                remark: duration of suspend mode in minutes (gets converted automatically)
                type: num
                visu_acl: rw
                cache: True
                enforce_updates: True
                initial_value: -1
                on_change: .seconds = value * 60 if not sh..self.property.last_change_by in ["On_Change:{}".format(sh..seconds.property.path), "On_Change:{}".format(sh..duration_format.property.path)] else None
                on_update: .seconds = value * 60 if "Init" in sh..self.property.last_update_by else None

                duration_format:
                    remark: Can be used for the clock.countdown widget and smartvisu
                    type: str
                    cache: True
                    visu_acl: rw
                    on_change: ..seconds = sum([a*b for a,b in zip([216000,3600,60,1], map(int,value.replace('d','').replace('h','').replace('i','').replace('s','').split(' ')))]) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...seconds.property.path), "On_Update:{}".format(sh...seconds.property.path)] else None

                seconds:
                    remark: duration of suspend mode in seconds (gets converted automatically)
                    type: num
                    visu_acl: rw
                    cache: True
                    on_change:
                      - .. = value / 60 if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh....property.path), "On_Update:{}".format(sh....property.path)] else None
                      - ..duration_format = '{}d {}h {}i {}s'.format(int(value//86400), int((value%86400)//3600), int((value%3600)//60), round((value%3600)%60)) if not sh..self.property.last_change_by in [ "On_Change:{}".format(sh...duration_format.property.path), "On_Update:{}".format(sh...duration_format.property.path)] else None

            suspend_active:
                remark: Use this to (de)activate suspend mode in general
                type: bool
                visu_acl: rw
                cache: True
                initial_value: True

            settings_edited:
                type: bool
                name: settings editiert
                eval_trigger: ...settings.*
                eval: not sh..self()
                on_update: ...retrigger = True if sh..self.property.prev_update_age > 0.1 else None

        rules:
            se_item_suspend: ..suspend
            se_item_suspend_visu: ..suspend.visu
            se_item_suspend_end: ..suspend_end.date_time
            se_item_suspend_start: ..suspend_start.date_time
            se_item_suspend_active: ..settings.suspend_active
            se_item_suspendvariant: ..settings.suspendvariant
            se_suspend_time: eval:se_eval.get_relative_itemvalue('..settings.suspendvariant.suspendduration{}.seconds'.format(max(0, min(se_eval.get_relative_itemvalue('..settings.suspendvariant'), 2))))

            eval_trigger:
                - ..manuell

            suspend:
                name: ausgesetzt
                se_use: eval:se_eval.get_relative_itemvalue('..settings.suspendvariant.additionaluse{}'.format(max(0, min(se_eval.get_relative_itemvalue('..settings.suspendvariant'), 2))))

                on_enter:
                    se_action_suspend_visu:
                      - 'function: set'
                      - 'to: True'
                      - 'order: 2'

                on_enter_or_stay:
                    se_action_suspend:
                      - 'function: special'
                      - 'value: suspend:..suspend, ..manuell'
                      - 'repeat: True'
                      - 'order: 1'
                    se_action_suspend_end:
                      - 'function: set'
                      - "to: eval:se_eval.insert_suspend_time('..suspend', suspend_text='%Y-%m-%d %H:%M:%S.%f%z')"
                      - 'repeat: True'
                      - 'order: 3'
                    se_action_suspend_start:
                      - 'function: set'
                      - "to: eval:str(shtime.now())"
                      - 'repeat: True'
                      - 'conditionset: (.*)enter_manuell'
                      - 'order: 4'
                    se_action_retrigger:
                      - 'function: special'
                      - 'value: retrigger:..retrigger'
                      - 'delay: var:item.suspend_remaining'
                      - 'repeat: True'
                      - 'order: 5'

                on_pass:
                    se_action_suspend:
                      - 'function: set'
                      - 'to: False'
                      - 'repeat: False'
                    se_action_suspend_visu:
                      - 'function: set'
                      - 'to: False'
                      - 'repeat: False'
                    se_action_suspend_end:
                      - 'function: set'
                      - 'to:  '
                      - 'repeat: False'
                    se_action_suspend_start:
                      - 'function: set'
                      - 'to:  '
                      - 'repeat: False'

                on_leave:
                    se_action_suspendvariant:
                      - 'function: set'
                      - 'to: eval:se_eval.get_relative_itemproperty("..settings.suspendvariant", "last_value")'
                      - 'order: 1'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_suspend:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 2'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_suspend_visu:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 3'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_suspend_end:
                      - 'function: set'
                      - 'to:  '
                      - 'order: 4'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_suspend_start:
                      - 'function: set'
                      - 'to:  '
                      - 'order: 5'
                      - 'delay: 1'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'
                    se_action_retrigger:
                      - 'function: special'
                      - 'value: retrigger:..retrigger'
                      - 'delay: -1'
                      - 'order: 1'
                      - 'nextconditionset: item:..settings.conditionset_leaveactions.suspend'

                enter_manuell:
                    se_value_trigger_source: eval:se_eval.get_relative_itemproperty('..manuell', 'path')
                    se_value_suspend_active: True

                enter_stay:
                    se_value_laststate: var:current.state_id
                    se_agemax_suspend: var:item.suspend_time
                    se_value_suspend: True
                    se_value_suspend_active: True

    state_standard:
        name: leerer Zustand (z.B. Standard)
        rules:
            standard:
                name: standard

                enter_manuell:
                    type: foo

    state_release:
        name: Zustandsvorlage für Deaktivieren von Suspend und Lock und erneutes Evaluieren der Regeln

        release:
            type: bool
            knx_dpt: 1
            visu_acl: rw
            enforce_updates: True
            on_update: ..rules = True if value is True else None
            autotimer: 1 = False

        suspend:
            type: bool
            knx_dpt: 1
            visu_acl: rw
            cache: True

            visu:
                type: bool
                knx_dpt: 1
                visu_acl: rw
                cache: True

        suspend_end:
            type: str
            visu_acl: ro
            eval: "'' if not any(char.isdigit() for char in sh..self.date_time()) else sh..self.date_time().split(' ')[1].split('.')[0]"
            eval_trigger: .date_time
            crontab: init

            date_time:
                type: str
                visu_acl: ro
                cache: True

            unix_timestamp:
                type: num
                visu_acl: ro
                eval: "0 if not any(char.isdigit() for char in sh...date_time()) else  shtime.datetime_transform(sh...date_time()).timestamp() * 1000"
                eval_trigger: ..date_time
                crontab: init

        suspend_start:
            type: str
            visu_acl: ro
            eval: "'' if not any(char.isdigit() for char in sh..self.date_time()) else sh..self.date_time().split(' ')[1].split('.')[0]"
            eval_trigger: .date_time
            crontab: init

            date_time:
                type: str
                visu_acl: ro
                cache: True

            unix_timestamp:
                remark: Can be used for the clock.countdown widget
                type: num
                visu_acl: ro
                eval: "0 if not any(char.isdigit() for char in sh...date_time()) else  shtime.datetime_transform(sh...date_time()).timestamp() * 1000"
                eval_trigger: ..date_time
                crontab: init

        rules:
            se_item_lock: ..lock
            se_item_suspend: ..suspend
            se_item_suspend_visu: ..suspend.visu
            se_item_release: ..release
            se_item_suspend_end: ..suspend_end.date_time
            se_item_suspend_start: ..suspend_start.date_time

            release:
                name: release

                on_enter:
                    se_action_suspend:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 1'
                    se_action_suspend_visu:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 2'
                    se_action_lock:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 3'
                    se_action_suspend_start:
                      - 'function: set'
                      - 'to: '
                      - 'order: 4'
                    se_action_release:
                      - 'function: set'
                      - 'to: False'
                      - 'order: 5'
                    se_action_retrigger:
                      - 'function: special'
                      - 'value: retrigger:..retrigger'
                      - 'repeat: True'
                      - 'order: 6'

                enter:
                    se_value_release: True

item_attribute_prefixes:
    # Definition of item attributes that only have a common prefix (enter 'item_attribute_prefixes: NONE' or ommit this section, if section should be empty)
    # NOTE: This section should only be used, if really nessesary (e.g. for the stateengine plugin)
    se_item_:
        type: foo
        description:
            de: 'Definiert das Item, das in einem konkreten Zustand evaluiert oder geändert werden soll'
            en: 'Definition of an item that should be evaluated or changed in a specific state'

    se_status_:
        type: foo
        description:
            de: 'Definiert das Item, das in einem konkreten Zustand evaluiert werden soll'
            en: 'Definition of an item that should be evaluated in a specific state'

    se_eval_:
        type: foo
        description:
            de: 'Wie se_item, allerdings wird anstatt des konkreten Items das Item durch einen eval Ausdruck bestimmt'
            en: 'Like se_item but instead of a specific item the item gets defined by an eval expression'

    se_mindelta_:
        type: foo
        description:
            de: 'Definiert um welchen Wert sich das Item mindestens geändert haben muss, um neu gesetzt zu werden'
            en: 'Definition of a threshold the item has to surpass to be newly set'

    se_minagedelta_:
        type: foo
        description:
            de: 'Definiert eine Pause zwischen mehreren Aktionsaufrufen.'
            en: 'Definition of pause interval between multiple runs of actions'

    se_min_:
        type: foo
        description:
            de: 'Bedingung: Der Wert eines Items muss mindestens so hoch wie durch se_min angegeben sein'
            en: 'Condition: The value of the item has to be at least as high as defined by se_min'

    se_max_:
        type: foo
        description:
            de: 'Bedingung: Der Wert eines Items muss niedriger als der durch se_max angegebene Wert sein'
            en: 'Condition: The value of the item has to be lower than defined by se_max'

    se_value_:
        type: foo
        description:
            de: 'Bedingung: Das Item muss exakt dem durch se_value angegebenem Wert entsprechen'
            en: 'Condition: The item has to have the exact same value as defined by se_value'

    se_negate_:
        type: bool
        description:
            de: 'Bedingung: Invertieren eines zuvor (mittels min, max oder value) definierten Bedingungswertes'
            en: 'Condition: Invert a condition value previously defined (by min, max or value)'

    se_agemin_:
        type: foo
        description:
            de: 'Bedingung: Mindestalter des Items (äquivalent zu se_minage)'
            en: 'Condition: Minimum age of an item (same as se_minage)'

    se_agemax_:
        type: foo
        description:
            de: 'Bedingung: Maximalalter des Items (äquivalent zu se_maxage)'
            en: 'Condition: Maximum age of an item (same as se_maxage)'

    se_minage_:
        type: foo
        description:
            de: 'Bedingung: Mindestalter des Items (äquivalent zu se_agemin)'
            en: 'Condition: Minimum age of an item (same as se_agemin)'

    se_maxage_:
        type: foo
        description:
            de: 'Bedingung: Maximalalter des Items (äquivalent zu se_agemax)'
            en: 'Condition: Maximum age of an item (same as se_agemax)'

    se_agenegate_:
        type: bool
        description:
            de: 'Bedingung: Invertieren des zuvor definierten Alterswerts'
            en: 'Condition: Invert a previously defined age value'

    se_changedby_:
        type: list
        description:
            de: 'Bedingung: Item wurde geändert durch..'
            en: 'Condition: Item was changed by..'

    se_changedbynegate_:
        type: bool
        description:
            de: 'Bedingung: Invertieren des zuvor definierten changedby Werts'
            en: 'Condition: Invert a previously defined changedby value'

    se_updatedby_:
        type: list
        description:
            de: 'Bedingung: Item wurde aktualisiert durch..'
            en: 'Condition: Item was updated by..'

    se_updatedbynegate_:
        type: bool
        description:
            de: 'Bedingung: Invertieren des zuvor definierten updatedby Werts'
            en: 'Condition: Invert a previously defined updatedby value'

    se_action_:
        type: list
        description:
            de: 'Definiert eine Aktion wie Setzen von Items, Ausführen von Logiken, etc.'
            en: 'Definition of an action like setting an item, running logics, etc.'

    se_special_:
        type: str
        description:
            de: 'Sonderaktion wie Suspend oder Retrigger'
            en: 'Special action like suspend or retrigger'

    se_set_:
        type: foo
        description:
            de: 'Setzen eines Items auf einen bestimmten Wert (veraltet - Nutze stattdessen se_action)'
            en: 'Setting an item to a specific value (deprecated - use se_action instead)'

    se_force_:
        type: foo
        description:
            de: 'Setzen eines Items auf einen bestimmten Wert, egal ob sich der Wert geändert hat oder nicht (veraltet - Nutze stattdessen se_action)'
            en: 'Setting an item to a specific value no matter whether the value has changed or not (deprecated - use se_action instead)'

    se_run_:
        type: str
        description:
            de: 'Ausführen eines eval Ausdrucks (veraltet - Nutze stattdessen se_action)'
            en: 'Running an eval expression (deprecated - use se_action instead)'

    se_trigger_:
        type: str
        description:
            de: 'Ausführen einer Logik (veraltet - Nutze stattdessen se_action)'
            en: 'Running a logic (deprecated - use se_action instead)'

    se_byattr_:
        type: str
        description:
            de: 'Setzen aller Items mit dem entsprechend angegebenen Attribut (veraltet - Nutze stattdessen se_action)'
            en: 'Setting all items having the respective attribute (deprecated - use se_action instead)'

    se_delay_:
        type: foo
        description:
            de: 'Verzögern einer Aktion (veraltet - Nutze stattdessen se_action)'
            en: 'Delaying an action (deprecated - use se_action instead)'

    se_repeat_:
        type: foo
        description:
            de: 'Definiert, ob eine Aktion beim erneuten Eintritt in den gleichen Status wiederholt werden soll oder nicht (veraltet - Nutze stattdessen se_action)'
            en: 'Definition wether an action should be repeated or not when reentering the same state (deprecated - use se_action instead)'

    se_order_:
        type: foo
        description:
            de: 'Definiert die Reihenfolge einer Aktion als Integerzahl (veraltet - Nutze stattdessen se_action)'
            en: 'Definition of the running order of an action as integer (deprecated - use se_action instead)'

    se_manual_:
        type: foo
        description:
            de: 'Diverse Funktion für den Suspendmodus wie include, exclude, invert, logitem.'
            en: 'Some functions relevant for the suspend mode like include, exclude, invert, logitem.'

    se_template_:
        type: str
        description:
            de: 'Definiert eine Vorlage, auf die per template:<name> zurückgegriffen werden kann.'
            en: 'Definition of a template that can be referenced by template:<name>.'

plugin_functions: NONE
    # Definition of plugin functions defined by this plugin (enter 'plugin_functions: NONE', if section should be empty)

logic_parameters: NONE
    # Definition of logic parameters defined by this plugin (enter 'logic_parameters: NONE', if section should be empty)
