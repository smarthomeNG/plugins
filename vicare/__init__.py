#!/usr/bin/env python3
# vim: set encoding=utf-8 tabstop=4 softtabstop=4 shiftwidth=4 expandtab
#########################################################################
#  Copyright 2023 Alexander Schwithal
#########################################################################
#  This file is part of SmartHomeNG.   
#
#  Plugin to connect with Viessman ViCare Backend
#
#  SmartHomeNG is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  SmartHomeNG is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with SmartHomeNG. If not, see <http://www.gnu.org/licenses/>.
#
#########################################################################

from lib.model.smartplugin import *
from lib.item import Items
from .webif import WebInterface

import sys
import requests
import json
import string

# Necessary python package for funktion "generate_code_verifier":
from authlib.common.security import generate_token

AUTHORIZE_URL = 'https://iam.viessmann.com/idp/v3/authorize'
TOKEN_URL = 'https://iam.viessmann.com/idp/v3/token'

class Vicare(SmartPlugin):
    PLUGIN_VERSION = '1.9.5'

    def __init__(self, sh):
        """
        Initalizes the plugin.

        """

        # Call init code of parent class (SmartPlugin)
        super().__init__()

        self._sh = sh
        self._cycle = 60
        self.session = requests.Session()
        self.clientID = ''                                   # clientID, configured via Viessmann account. Mandatory via plugin.yaml
        self.redirectUrl = self.get_parameter_value('redirectUrl')
        self.codeVerifier = ''                               # private verifier code, generated by plugin function
        self.codeChallenge = ''                              # public challenge code, generated by plugin function from codeVerifier
        self.accessToken = ''                                # accessToken, necessary for authentication, only valid for 1 hour.
        self.refreshToken = ''                               # refreshToken, necessary for obtaining new accessToken very hour, valid for 180 days.
        self.user = self.get_parameter_value('user')
        self.password = self.get_parameter_value('password')
        self.installationId = ''                             # installation ID, unique for the whole viessmann installation
        self.gatewaySerial = ''
        self.deviceId = ''
        self.featureListJson = {}                            # List of all available features as Json
        self.deviceListJson = {}                             # List of all available devices as Json
        self.nr_devices = 0                                  # Number of devices
        self.deviceType = 'unknown'
        self.modelId = 'unknown'
        self.authRequestUrl = ''
        self.onlineStatue = False
        self._rx_items = []                                  # list of rx items that are updated by this plugin
        self._tx_items = []                                  # list of tx items that can trigger control actions, e.g. setting temperature.
        self.verbose = False
        self.fixed_cylces_to_renew = int(1800/self._cycle)   # refresh every 30 minutes
        self.count_to_renew = 0                              # Counter that is increased in poll_backend task

        # Check plugin parameters:
        temp = self.get_parameter_value('clientID')
        if not temp == '':
            self.clientID = temp
            self.logger.debug(f"Loaded clientID: {self.clientID}")
        else:
            self.logger.error("ClientID not configured for pluging. Please register device via Viessmann developper portal.")

        temp = self.get_parameter_value('accessToken')
        if not temp == '':
            self.accessToken = temp
            self.logger.info(f"Successfully loaded accessToken from plugin.yaml: {self.accessToken}")

        temp = self.get_parameter_value('refreshToken')
        if not temp == '':
            self.refreshToken = temp
            self.logger.info(f"Successfully loaded refresh token from plugin.yaml: {self.refreshToken}")
        
        self.init_webinterface(WebInterface)
        self.logger.debug("Init completed.")
        return 

    def run(self):
        self.logger.debug("Run method called")

        if not self.refreshToken == '':
            self.refresh_accessToken()

        # Poll installation setup once: 
        self.pollInstallationId()
        self.pollSerial()
        self.pollDevices()

        self.pollFeatures()
        self.decodeFeatures(self.featureListJson, log_features = True)

        self.scheduler_add('poll_backend', self.poll_backend, prio=5, cycle=self._cycle)
        self.alive = True

    def stop(self):
        self.logger.debug("Stop method called")
        self.alive = False
        self.scheduler_remove('poll_backend')

    def parse_item(self, item):
        
        """
        Default plugin parse_item method. Is called when the plugin is initialized. Selects each item corresponding to
        the vicare attribute and adds it to an internal array

        :param item: The item to process.
        """
        if self.get_iattr_value(item.conf, 'vicare_rx_key'):
            self._rx_items.append(item)
            #self.logger.debug(f"rx-items dict: {self._rx_items}")

        if self.has_iattr(item.conf, 'vicare_tx_key'):
            # register item for event handling via smarthomeNG core. Needed for sending control actions:
            if not self.has_iattr(item.conf, 'vicare_tx_path'):
                self.logger.error(f"Vicare tx item {item} is missing attribute vicare_tx_path.")
                return
            self._tx_items.append(item)
            return self.update_item

    def parse_logic(self, logic):
        pass

    def update_item(self, item, caller=None, source=None, dest=None):
        self.logger.debug(f"Update vicare item: Caller: {caller}, pluginname: {self.get_shortname()}")
        if caller != self.get_shortname():
            if self.has_iattr(item.conf, 'vicare_tx_key'):
                tx_key = item.conf['vicare_tx_key']
                tx_path = item.conf['vicare_tx_path']
                self.logger.debug(f"Updated item {item} with tx_key: {tx_key}")
                uri, tag, type, min, max, stepping, enumList = self.decodeCommandFeature(self.featureListJson, vicare_tx_key = tx_key, vicare_tx_path = tx_path, log_features = False)
                self.logger.debug(f"uri, tag, type, min, max, stepping: {uri},{tag},{type},{min},{max},{stepping}")
                if uri is not None:
                    self.controlItem(url=uri, tag=tag, type=type, min=min, max=max, stepping=stepping, enumList=enumList, value=item())
                else:
                    self.logger.debug(f"Item {item} cannot be controlled because no valid command url was found. Aborting.")
            else:
                self.logger.error(f"Item {item} is missing the attribute vicare_tx_key.")
        pass

    ############################################################
    # Getter/Setter
    ############################################################

    def enablePolling(enable = True):
        self.pollData = enable

    def set_refreshToken(self, refreshToken):
        self.refreshToken = refreshToken

    def get_refreshToken(self):
        return self.refreshToken

    def get_accessToken(self):
        return self.accessToken

    def get_codeVerifier(self):
        return self.codeVerifier

    def set_codeVerifier(self, codeVerifier):
        if codeVerifier == '':
            self.logger.warning(f"set_codeVerifier: Argument is empty!")
        self.codeVerifier = codeVerifier

    ############################################################
    # Authentication functions
    ############################################################

    def generate_code_verifier(self):
        self.codeVerifier = generate_token(64)
        self.logger.warning(f"Generated code verifier {self.codeVerifier}")

    def calculate_code_challenge(self, codeVerifier=''):
        # Calculate code challenge for given codeVerifier, doublechecked with online tool 
        # https://developer.pingidentity.com/en/tools/pkce-code-generator.html
        # From code example: https://www.stefaanlippens.net/oauth-code-flow-pkce.html
    
        import base64 
        import hashlib
        
        if codeVerifier == '':
            self.logger.error(f"calculate_code_challenge: codeVerifier is empty.")
            return
        codeChallenge = hashlib.sha256(codeVerifier.encode('utf-8')).digest()
        codeChallenge = base64.urlsafe_b64encode(codeChallenge).decode('utf-8')
        codeChallenge = codeChallenge.replace('=', '')
        self.codeChallenge = codeChallenge
        self.logger.info(f"Code challenge ({len(codeChallenge)}) calculated: {codeChallenge}")

    def generate_request_url(self):
        if self.clientID == '':
            self.logger.error(f"generate_request_url: clientID is missing")
            return False
        if self.redirectUrl == '':
            self.logger.error(f"generate_request_url: Redirect URL is missing")
            return False
        if self.codeChallenge == '':
            self.logger.error(f"generate_request_url: code challenge is missing")
            return False

        url = f"{AUTHORIZE_URL}?client_id={self.clientID}&redirect_uri={self.redirectUrl}&scope=IoT%20User%20offline_access&response_type=code&code_challenge_method=S256&code_challenge={self.codeChallenge}"
        self.authRequestUrl = url
        self.logger.warning(f"Copy paste this url to browser to request a code: {url}")
        return True

    def refresh_accessToken(self): 
        # Refreshes the accessToken validity by using the refresh token. Works up to 180 days.
        # Procedure is described on: https://documentation.viessmann.com/static/authentication
        # Return True on success and False otherwise

        if self.refreshToken == '':
            self.logger.error(f"No refresh token available. Aborting.")
            return False

        self.logger.debug(f"Refreshing accessToken...")
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        data = {}
        data['grant_type'] = "refresh_token"
        data['client_id'] = f"{self.clientID}"
        data['refresh_token'] = f"{self.refreshToken}"
        try:
            response = self.session.post(TOKEN_URL, headers = headers, data = data, verify=False, timeout=4)
        except Exception as e:
            self.logger.warning(f"Exception occurred during refresh token request: {e}")
            return False

        if response is None:
            return False

        if response.status_code == 200:
            self.logger.info(f"Refresh token request successfull")
        else:
            self.logger.warning(f"Refresh token request was unsuccessfull. Status code: {response.status_code}")
            self.logger.warning(f"Refresh token request was unsuccessfull. Response: {response.text}")
            return False
        
        responseJson = response.json()
        if 'access_token' in responseJson :
            accessToken = responseJson['access_token']
            self.logger.info(f"SUCCESS: accessToken is {accessToken}")
            self.accessToken = accessToken
            param_dict = {"accessToken": str(self.accessToken)}
            self.update_config_section(param_dict)
            self.logger.debug(f"Successfully saved accessToken in plugin.yaml")
            return True
        else:
            self.logger.error(f"refreshToken: Response did not contain an access token!")
            return False

    def retrieve_accessToken(self, code):
        # pass code from login procedure, see browser argument on redirected page:        

        accessToken = ''
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        data = {}
        data['grant_type'] = "authorization_code"
        data['code_verifier'] = f"{self.codeVerifier}"
        data['client_id'] = f"{self.clientID}"
        data['redirect_uri'] = f"{self.redirectUrl}"
        data['code'] = f"{code}"

        self.logger.debug(f"Debug retrieve accessToken Data: {data}")
        try:
            responseGetToken = self.session.post(TOKEN_URL, headers = headers, data = data, verify=False, timeout=4)
        except Exception as e:
            self.logger.error(f"Exception occured during retrieve token: {e}")
            return False

        if responseGetToken is None:
            self.logger.error(f"Retrieve token returned None")
            return False

        if responseGetToken.status_code == 200:
            self.logger.info(f"get token request successfull")
        else:
            self.logger.warning(f"get token request was unsuccessfull. Status code: {responseGetToken.status_code}")
            return False

        self.logger.info(f"Request for token request was successfull")
        responseGetTokenJson = responseGetToken.json()
        self.logger.debug(f"Request for token request as json: {responseGetTokenJson }")
        if 'access_token' in responseGetTokenJson:
            accessToken = responseGetTokenJson['access_token']
            self.logger.info(f"SUCCESS: Request token is {accessToken}")
            self.logger.warning(f"Debug: SUCCESS: Request token is {accessToken}")
            self.accessToken = accessToken
            param_dict = {"accessToken": str(self.accessToken)}
            self.update_config_section(param_dict)
            self.logger.debug(f"Successfully saved accessToken in plugin.yaml")
#            self.pollData = True
        else:
            self.logger.error(f"Response did not contain an access token!")
            return False

        if 'refresh_token' in responseGetTokenJson:
            refreshToken = responseGetTokenJson['refresh_token']
            self.logger.info(f"SUCCESS: Refresh token is {refreshToken}")
            self.refreshToken = refreshToken 
            param_dict = {"refreshToken": str(self.refreshToken)}
            self.update_config_section(param_dict)
            self.logger.debug(f"Successfully saved refreshToken in plugin.yaml")
        else:
            self.logger.error(f"Response did not contain a refresh token!")
            return False

        if 'expires_in' in responseGetTokenJson:
            expires_in = responseGetTokenJson['expires_in']
            self.logger.info(f"Token expire in {expires_in} seconds")

        else:
            self.logger.error(f"Token request was not successfull")
            return False

        return True         


    ######################################################################
    #   Poll functions
    ######################################################################

    def poll_backend(self):
        self.logger.debug(f"Polling viessmann backend.")
           
        # Token refresh mechanism:   
        self.count_to_renew = self.count_to_renew + 1
        if self.count_to_renew >= self.fixed_cylces_to_renew:
            self.logger.debug(f"Refreshing token...")
            if self.refresh_accessToken() == True:
                self.count_to_renew = 0
#        else:
#            self.logger.debug(f"{self.fixed_cylces_to_renew - self.count_to_renew} remaining cycles to refresh token.")

        # Poll installation setup only if data are invalid: 
        if self.installationId == '':
            self.logger.debug(f"poll_backend: installationId is empty, trying to update")
            self.pollInstallationId()
        if self.gatewaySerial == '':
            self.logger.debug(f"poll_backend: gatewaySerial is empty, trying to update")
            self.pollSerial()        
        if self.deviceId == '':
            self.logger.debug(f"poll_backend: deviceID is empty, trying to update")
            self.pollDevices()

        # Poll data from backend:
        self.pollFeatures()
        self.decodeFeatures(self.featureListJson, log_features = False)


    def pollUrlInterface(self, url): 
        headers={}
        headers['Authorization'] = f"Bearer {self.accessToken}"
        response = None
        try:
            response = self.session.get(url, headers = headers, verify=False, timeout=4)
        except Exception as e:
            self.logger.warning(f"Exception occured during pollUrlInterface: {e}")
        return response

    def checkErrors(self, response):
        responseJson = response.json()
        
        if 'error' in responseJson:
            if 'message' in responseJson:
                message = responseJson['message']
                self.logger.error(f"Error occured: {message}")
            return True
        return False


    def pollInstallationId(self):
        url = f"https://api.viessmann.com/iot/v1/equipment/installations"
        response = self.pollUrlInterface(url)
        
        if response is None:
            return
        if response.status_code == 200:
            self.logger.debug(f"pollInstallationId request successfull")
        else:
            self.logger.warning(f"pollInstallationId request was unsuccessfull. Status code: {response.status_code}, Text: {response.text}")
            return

        if response.json() is not None:
            responseJson = response.json() 
            #self.logger.debug(f"PollInstallation: {responseJson}")
        
            if self.checkErrors(response) == True: 
                return
   
            if 'data' in responseJson:
                dataJson = responseJson['data']
                #self.logger.warning(f"Debug dataJson: {dataJson}")
                #self.logger.warning(f"Debug dataJson[0]: {dataJson[0]}")

                nr_installations = len(dataJson)
                if nr_installations > 1:
                    self.logger.warning(f"pollInstallationId: {nr_installations} installations found but only the first is decoded.")

                dataJson_0 = dataJson[0]
                if 'id' in dataJson_0:
                    self.installationId = dataJson_0['id']
                    self.logger.info(f"InstallationId is {self.installationId}")

    def pollSerial(self):
        url = f"https://api.viessmann.com/iot/v1/equipment/gateways"
        response = self.pollUrlInterface(url)

        if response is None:
            return
        if response.status_code == 200:
            self.logger.debug(f"pollSerial request successfull")
        else:
            self.logger.warning(f"pollSerial request was unsuccessfull. Status code: {response.status_code}")
            return
    
        if response.json() is not None:
            responseJson = response.json()

            if self.checkErrors(response) == True: 
                return
        
            if 'data' in responseJson:
                dataJson = responseJson['data']
                #self.logger.warning(f"Debug dataJson: {dataJson}")
                #self.logger.warning(f"Debug dataJson[0]: {dataJson[0]}")
                dataJson_0 = dataJson[0]
                if 'serial' in dataJson_0:
                    self.gatewaySerial = dataJson_0['serial']
                    self.logger.info(f"Serial is {self.gatewaySerial}")

    def pollDevices(self):
        if self.gatewaySerial == '':
            self.logger.debug(f"pollSerial, invalid gatewaySerial, aborting!")
            return
        if self.installationId == '':
            self.logger.debug(f"pollSerial, invalid installationId, aborting!")
            return

        url = f"https://api.viessmann.com/iot/v1/equipment/installations/{self.installationId}/gateways/{self.gatewaySerial}/devices"
        response = self.pollUrlInterface(url)
        
        if response is None:
            return
        if response.status_code == 200:
            self.logger.debug(f"pollDevices request successfull: {response.text}")
        else:
            self.logger.warning(f"pollDevices request was unsuccessfull. Status code: {response.status_code}")
            return
    
        if response.json() is not None:
            responseJson = response.json()

            if self.checkErrors(response) == True: 
                return

            if 'data' in responseJson:
                self.deviceListJson = responseJson['data']
                dataJson = responseJson['data']

                self.nr_devices = len(dataJson)
                index_of_device = 0
                if self.nr_devices > 1:
                    self.logger.info(f"pollDevices: Found {self.nr_devices} devices.")
                    found_valid_serial = False
                    # Determine device of interest by picking the first device having a valid boiler serial number:
                    for i in range(0,self.nr_devices):
                        if 'boilerSerial' in dataJson[i] and (dataJson[i]['boilerSerial'] is not None):
                            found_valid_serial = True
                            index_of_device = i
                            self.logger.info(f"pollDevices: Decoding device with index {index_of_device} and boiler serial number:{dataJson[i]['boilerSerial']}")
                
                    if found_valid_serial == False:
                        self.logger.error(f"pollDevices: No device with valid boiler serial number found. Perhaps plugin has to be extended for additional device types. Aborting decoding.")
                        return

                dataJson_device = dataJson[index_of_device]

                boilerSerial = None
                              
                if 'id' in dataJson_device :
                    self.deviceId = dataJson_device ['id']
                    self.logger.info(f"DeviceId is {self.deviceId}")
                if 'boilerSerial' in dataJson_device :
                    boilerSerial = dataJson_device ['boilerSerial']
                    self.logger.info(f"BoilerSerial is {boilerSerial}")
                if 'modelId' in dataJson_device :
                    self.modelId = dataJson_device ['modelId']
                    self.logger.info(f"modelId is {self.modelId}")
                if 'status' in dataJson_device :
                    status = dataJson_device ['status']
                    self.logger.info(f"Status is {status}")
                if 'deviceType' in dataJson_device :
                    self.deviceType = dataJson_device ['deviceType']
                    self.logger.info(f"deviceType is {self.deviceType}")

                # Copy data in viessmann items:
                # TODO: Extend rx_item struct to with serial number for multiple devices, aka self._rx_items[unitID]:
                for item in self._rx_items:
                    rx_key = item.conf['vicare_rx_key']
                    if rx_key == 'boilerSerial':
                        if boilerSerial:
                            item(boilerSerial, self.get_shortname())
            else:
                # No data available in response
                self.deviceListJson = {}

    def pollFeatures(self):
        self.featureListJson = {}

        if self.gatewaySerial == '':
            self.logger.debug(f"pollFeatures, invalid gatewaySerial, aborting!")
            return
        if self.installationId == '':
            self.logger.debug(f"pollFeatures, invalid installationId, aborting!")
            return
        if self.deviceId == '':
            self.logger.debug(f"pollFeatures, invalid deviceId, aborting!")
            return

        url = f"https://api.viessmann.com/iot/v2/features/installations/{self.installationId}/gateways/{self.gatewaySerial}/devices/{self.deviceId}/features"
        response = self.pollUrlInterface(url)
        if response is None:
            return
        if response.status_code == 200:
            self.logger.debug(f"pollFeatures: request successfull, response: {response.text}")
        else:
            self.logger.warning(f"pollFeatures request was unsuccessfull. Status code: {response.status_code}")
            if not response.text == "":
                self.logger.warning(f"pollFeatures Debug response: {response}, response.text: {response.text}")
            return
    
        if response.json() is not None:
            responseJson = response.json()

            if self.checkErrors(response) == True:
                return

            if 'data' in responseJson:
                self.featureListJson = responseJson['data']
                nr_features = len(self.featureListJson)
                self.logger.info(f"Found {nr_features} features")
        
        if len(self.featureListJson) == 0:
            self.logger.warning(f"pollFeature: No Features found")


    def decodeFeatures(self, featureList, log_features = False):
        nr_features = len(featureList)
        self.onlineStatus = nr_features > 0
        
        if nr_features >= 0:
            for i in range(0,nr_features):
                #self.logger.debug(f"Extracting feature {i+1}")
                properties = None
                featureItem = featureList[i]
                isEnabled = False
                if 'isEnabled' in featureItem:
                    isEnabled = featureItem['isEnabled']
                    if isEnabled and log_features:
                        self.logger.info(f"Feature: {i+1} isEnabled: {isEnabled}")
                if 'uri' in featureItem:
                    uri = featureItem['uri']
                    if isEnabled and log_features:
                        self.logger.info(f"uri: {uri}")
                if 'feature' in featureItem:
                    feature = featureItem['feature']
                    if isEnabled and log_features:
                        self.logger.info(f"feature: {feature}")                    
                if 'isReady' in featureItem:
                    isReady = featureItem['isReady']
                    if isEnabled and log_features:
                        self.logger.info(f"isReady: {isReady}")
                if 'commands' in featureItem:
                    commands = featureItem['commands']
                    if not commands == {}:
                        if isEnabled and log_features:
                            self.logger.info(f"Available commands: {commands}")
                if 'properties' in featureItem:
                    properties = featureItem['properties']
                    if not properties == {}:
                        if isEnabled and log_features:
                            self.logger.info(f"Available properties: {properties}")

                #Copy feature data in viessmann items:
                for item in self._rx_items:
                    if (item.conf['vicare_rx_key'] == feature):
                        self.logger.debug(f"Vicare Item found for feature: {feature}. Updating")
                        if isEnabled and isReady and self.has_iattr(item.conf, 'vicare_path') and properties:
                            path = item.conf['vicare_path']
                            length_path = len(path)
                            #self.logger.debug(f"Item vicare path with {length_path} entries: {path}")

                            try:
                                value = properties[path[0]]
                            except Exception as e:
                                self.logger.error(f"Exception occured in path for item {item}: {e}")
                            else:
                                for k in range(1,length_path):
                                    try:
                                        value = value[path[k]]
                                    except Exception as e:
                                        self.logger.error(f"Exception occured in path loop for item {item}: {e}")
                                        value = None
                                
                                    #self.logger.debug(f"Debug k={k}, value: {value}")
                                item(value, self.get_shortname())
                        elif not self.has_iattr(item.conf, 'vicare_path'):
                            self.logger.warning(f"Rx Item {item} is missing the attribute vicare_path.")
                        else:
                            self.logger.warning(f"Vicare Item found for feature: {feature} but not marked as usable (enabled:{isEnabled}, ready:{isReady}, properties:{properties}, vicare_path:{self.has_iattr(item.conf, 'vicare_path')})")
        else:
            self.logger.debug(f"decodeFeatures, feature list is empty.")

        # Copy global data in viessmann items:
        for item in self._rx_items:
            rx_key = item.conf['vicare_rx_key']
            if rx_key == 'onlineStatus':
                item(self.onlineStatus, self.get_shortname())
                break

  
    def decodeCommandFeature(self, featureList, vicare_tx_key = '', vicare_tx_path = [], log_features = False):
        # Function returns arguments: uri, tag, type, min, max, stepping, enumList  

        nr_features = len(featureList)
        
        if nr_features == 0:
            self.logger.warning(f"decodeCommandFeature, feature list is empty. Aborting")
            return None, None, None, None, None, None, None

        if vicare_tx_key == '':
            self.logger.error(f"decodeCommandFeature, tx key is empty. Aborting")
            return None, None, None, None, None, None, None

        for i in range(0,nr_features):
            #self.logger.debug(f"Extracting feature {i+1}")
            commands = None
            feature = None
            isEnabled = False
            isExecutable = False
            uri = ''
            commandsItem = None
            tag = ''
            min = None
            max = None
            stepping = None
            type = None
            enumList = []

            featureItem = featureList[i]
            if 'feature' in featureItem:
                feature = featureItem['feature']
            if feature == vicare_tx_key:
                #self.logger.debug(f"Command feature found: {feature }")
                              
                if 'isEnabled' in featureItem:
                    isEnabled = featureItem['isEnabled']
                    if isEnabled and log_features:
                        self.logger.info(f"Feature: {i+1} isEnabled: {isEnabled}")
                if 'commands' in featureItem:
                    commandsItem = featureItem['commands']
                    if not commandsItem == {} and isEnabled and log_features:
                        self.logger.info(f"Debug: Available commands: {commandsItem}")
                
                    length_path = len(vicare_tx_path)
                    controlItem = commandsItem 
                    for k in range(0,length_path):
                        #self.logger.debug(f"Debug loop: k={k},txpath:{vicare_tx_path[k]}, Item: {controlItem}")
                        tag = tag = vicare_tx_path[k]
                        try:
                            controlItem = controlItem[vicare_tx_path[k]]
                        except Exception as e:
                            self.logger.error(f"Exception occurred: {e}")

                        if 'uri' in controlItem :
                            uri = controlItem['uri']
                        if 'isExecutable' in controlItem :
                            isExecutable = controlItem['isExecutable']
                        if 'type' in controlItem:
                            type = controlItem['type']
                        if 'constraints' in controlItem:
                            if 'min' in controlItem['constraints']:
                                min = controlItem['constraints']['min']
                            if 'max' in controlItem['constraints']:
                                max = controlItem['constraints']['max']
                            if 'stepping' in controlItem['constraints']:
                                stepping = controlItem['constraints']['stepping']
                            if 'enum' in controlItem['constraints']:
                                enumList = controlItem['constraints']['enum']


                if not uri == '' and isExecutable:
                    self.logger.debug(f"Debug: Execute command with uri,tag,type, min, max, stepping, enumList: {uri},{tag},{type},{min},{max},{stepping},{enumList}")
                    return uri, tag, type, min, max, stepping, enumList  
                break

        return None, None, None, None, None, None, None



    def controlItem(self, url, tag, type, min, max, stepping, enumList, value):
        headers={}
        headers['Authorization'] = f"Bearer {self.accessToken}"
        headers['content-type'] = f"application/json"
        if max and min and ((value > max) or (value < min)): 
            self.logger.warning(f"controlItem: Value ({value}) is not within allowed range ({min}-{max})")
            return 
 
        if stepping == 1:
            self.logger.warning(f"Value {value} will be round to integer {int(value)}")
            value = int(value)

        if enumList and len(enumList) > 0 and isinstance(value, str):
           if not value in enumList:
               self.logger.warning(f"controlItem: String value ({value}) is not in the list of allowed values ({enumList}). Aborting.")
               return
           else:
               self.logger.warning(f"Debug SUCCES: Value is on positive list.")

        # Some commands are sent without a value and only provide a url. 
        # Therefore, only sent additional data for commands with valid (data) types.
        jsonCommand = {}
        if type is not None:
            jsonCommand = {tag: value}
        else:
            # Items with no valid type would send the uri on every item state change. 
            # Here, only allow commands to be sent on positive item values (== bool state True)
            if not value:
                self.logger.debug(f"controlItem: Supressing sending for command without additional data because item is false")
                return
            self.logger.debug(f"controlItem: Sending command without additional data because to data type is supported")

        data = json.dumps(jsonCommand)
        self.logger.debug(f"Prepare control data: {data}")
        response = self.session.post(url, headers = headers, data = data, verify=False, timeout=4)
   
        if response is not None and response.status_code == 200:
            self.logger.info(f"controlItem request successfull")
        else:
            self.logger.warning(f"controlItem request was unsuccessfull. Status code: {response.status_code}, text: {response.text}")
            return

    ####################################################################

    # Not working, TODO: debug
    def generateAPIToken(self, codeVerifier = ''):
        from authlib.integrations.requests_client import OAuth2Session
        VIESSMANN_SCOPE = ["IoT, User, offline_access"]

        if self.redirectUrl == '':
            self.logger.error(f"Redirect Url is empty but necessary for token request. Aborting.")
            return 'error'

        if codeVerifier == '':
            self.logger.error(f"Code verifier is empty but necessary for token request. Aborting.")
            return 'error'

        self.logger.warning(f"Debug: Redirect URL is: {self.redirectUrl}")

        oauth_session = OAuth2Session(self.clientID, redirect_uri=self.redirectUrl, scope=VIESSMANN_SCOPE, code_challenge_method='S256')
        authorization_url, _ = oauth_session.create_authorization_url(AUTHORIZE_URL, code_verifier=codeVerifier)
        self.logger.warning(f"Authorization URL is: {authorization_url}")


        self.logger.warning(f"Debug: Sending authorization pos...")
        header = {'Content-Type': 'application/x-www-form-urlencoded'}
        response = requests.post(authorization_url, headers=header, auth=(self.user, self.password), allow_redirects=True)

        if response is None: 
            self.logger.error(f"generateAPIToken: response is None")
        if response.status_code == 200:
            self.logger.warning(f"SUCCESS: {response.json()}")
        elif response.status_code == 401:
            self.logger.error(f"PyViCareInvalidConfigurationError: {response.json()}")
            return 'error'

        if 'Location' not in response.headers:
            self.logger.error(f'Location not in response: {response.headers}')
            return 'error'
        else:
            self.logger.warning(f"SUCCESS: Location in response header: {response.headers}")

        self.logger.warning(f"Debug: Fetching token...")
        accessToken = None
        token = oauth_session.fetch_token(TOKEN_URL, authorization_response=response.headers['Location'], code_verifier=codeVerifier)

        self.logger.warning(f"Debug: token reponse: {token}")

        if oauth_session.token is None:
            self.logger.error(f"PyViCareInvalidCredentialsError")
            return 'error'
        else:                                                                 
            self.logger.warning(f"SUCCESS: Valid token received: {oauth_session.token}")
            self.accessToken = oauth_session.token
            param_dict = {"testaccessToken": str(self.accessToken)}
            self.update_config_section(param_dict)
            return self.accessToken

