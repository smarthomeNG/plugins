<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>multidevice.MD_Command API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multidevice.MD_Command</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# vim: set encoding=utf-8 tabstop=4 softtabstop=4 shiftwidth=4 expandtab
#########################################################################
#  Copyright 2020-      Sebastian Helms             Morg @ knx-user-forum
#########################################################################
#  This file aims to become part of SmartHomeNG.
#  https://www.smarthomeNG.de
#  https://knx-user-forum.de/forum/supportforen/smarthome-py
#
#  MD_Command and derived classes for MultiDevice plugin
#
#  SmartHomeNG is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  SmartHomeNG is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with SmartHomeNG. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#########################################################################

import logging
import re
from copy import deepcopy

if MD_standalone:
    from MD_Globals import (CMD_ATTR_PARAMS, CMD_STR_VAL_RAW, CMD_STR_VAL_UPP, CMD_STR_VAL_LOW, CMD_STR_VAL_CAP, CMD_STR_VALUE, CMD_STR_OPCODE, CMD_STR_PARAM, CMD_STR_CUSTOM, COMMAND_PARAMS, MINMAXKEYS)
    import datatypes as DT
else:
    from .MD_Globals import (CMD_ATTR_PARAMS, CMD_STR_VAL_RAW, CMD_STR_VAL_UPP, CMD_STR_VAL_LOW, CMD_STR_VAL_CAP, CMD_STR_VALUE, CMD_STR_OPCODE, CMD_STR_PARAM, CMD_STR_CUSTOM, COMMAND_PARAMS, MINMAXKEYS)
    from . import datatypes as DT


#############################################################################################################################################################################################################################################
#
# class MD_Command
#
#############################################################################################################################################################################################################################################

class MD_Command(object):
    &#34;&#34;&#34; MD_Command class for command data handling

    This class represents a general command that uses read_cmd/write_cmd or, if
    not present, opcode as payload for the connection. Data is supplied in the
    &#39;data&#39;-key values in the data_dict. DT type conversion is applied with default
    values.

    For attributes defined in commands.py, see explanation in the
    dev_example/commands.py file.

    This class serves as a base class for further format-specific command types.
    &#34;&#34;&#34;
    device_id = &#39;&#39;
    name = &#39;&#39;
    opcode = &#39;&#39;
    read = False
    write = False
    read_cmd = None
    write_cmd = None
    item_type = None
    reply_token = []
    reply_pattern = &#39;&#39;
    cmd_settings = None
    lookup = None
    _DT = None

    def __init__(self, device_id, command, dt_class, **kwargs):

        # get MultiDevice.device logger (if not already defined by derived class calling us via super().__init__())
        if not hasattr(self, &#39;logger&#39;):
            self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if not device_id:
            self.logger.warning(f&#39;building command {command} without a device, aborting&#39;)
        else:
            self.device_id = device_id

        if not command:
            self.logger.warning(&#39;building command without a name, aborting&#39;)
            return
        else:
            self.name = command

        kw = kwargs[&#39;cmd&#39;]
        self._plugin_params = kwargs[&#39;plugin&#39;]

        self._get_kwargs(COMMAND_PARAMS, **kw)

        try:
            self._DT = dt_class()
        except Exception as e:
            self.logger.error(f&#39;building command {command} failed on instantiating datatype class {dt_class}. Error was: {e}&#39;)
            self._DT = DT.DT_raw()

        # only log if base class. Derived classes log their own messages
        if self.__class__ is MD_Command:
            self.logger.debug(f&#39;learned command {command} with device datatype {dt_class} in {self.__class__.__name__}&#39;)

    def get_send_data(self, data, **kwargs):

        cmd = None

        data = self._check_value(data)

        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        return {&#39;payload&#39;: cmd, &#39;data&#39;: self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def get_lookup(self):
        &#34;&#34;&#34; getter for lookup &#34;&#34;&#34;
        return self.lookup

    def _get_kwargs(self, args, **kwargs):
        &#34;&#34;&#34;
        check if any items from args is present in kwargs and set the class property
        of the same name to its value.

        :param args: list or tuple of parameter names
        :type args: list | tuple
        &#34;&#34;&#34;
        for arg in args:
            if kwargs.get(arg, None):
                setattr(self, arg, kwargs[arg])

    def _check_min_max(self, data, key, min=True, force=False):
        &#34;&#34;&#34; helper routine to check for min/max compliance and int/float type &#34;&#34;&#34;
        if key in self.cmd_settings:
            bound = self.cmd_settings[key]
            if not isinstance(data, type(bound)):
                if type(data) is float and type(bound) is int:
                    data = int(data)
                elif type(data) is int and type(bound) is float:
                    data = float(data)
                else:
                    raise ValueError(f&#39;type {type(data)} ({data}) given for {type(bound)} ({bound})&#39;)
            if (min and data &gt;= bound) or (not min and data &lt;= bound):
                return data
            if force:
                self.logger.debug(f&#39;Value {data} changed to {bound} due to cmd_settings {self.cmd_settings}&#39;)
                return bound
            raise ValueError(f&#39;value {data} not adhering to {&#34;min&#34; if min else &#34;max&#34;} value {bound}&#39;)
        return data

    def _check_value(self, data):
        &#34;&#34;&#34;
        check if value settings are defined and if so, if they are followed
        possibly adjust data in accordance with settings

        non-compliance will raise ValueError

        This can be overwritten; make sure to call
        data = super()._check_value(data)
        to run this code in addition to your own extension, if applicable.
        Take care of the sequence of changing data, though...

        :param data: data/value to send
        :return: adjusted data
        &#34;&#34;&#34;
        if data is not None:
            try:
                if self.cmd_settings and not self.lookup:
                    if self.cmd_settings.get(&#39;valid_list_ci&#39;, None):
                        val = data
                        if isinstance(data, str):
                            val = data.lower()
                        if val not in self.cmd_settings[&#39;valid_list_ci&#39;]:
                            raise ValueError(f&#39;value {val} not in case insensitive list {self.cmd_settings[&#34;valid_list_ci&#34;]}&#39;)
                    elif self.cmd_settings.get(&#39;valid_list&#39;, None):
                        if data not in self.cmd_settings[&#39;valid_list&#39;]:
                            raise ValueError(f&#39;value {data} not in list {self.cmd_settings[&#34;valid_list&#34;]}&#39;)
                    # min/max not in addition to valid_list
                    elif any(key in self.cmd_settings.keys() for key in MINMAXKEYS):
                        for key in MINMAXKEYS:
                            data = self._check_min_max(data, key, key[-3:] == &#39;min&#39;, key[:5] == &#39;force&#39;)

            except Exception as e:
                raise ValueError(f&#39;Given invalid value for command {self.name} due to settings. Error was: {e}&#39;)

        return data


class MD_Command_Str(MD_Command):
    &#34;&#34;&#34; Command for string-based communication

    This class represents a command which uses a string with arguments as payload,
    for example as query URL.

    Default behaviour is identical to MD_Command.

    For sending, the read_cmd/write_cmd strings, opcode and data are parsed
    (recursively), to enable the following parameters:

    - &#39;{OPCODE}&#39; is replaced with the opcode,
    - &#39;{PARAM:attr}&#39; is replaced with the value of the attr element from the plugin configuration,
    - &#39;{VALUE}&#39; is replaced with the given value (converted by DT-class)
    - &#39;{CUSTOM_ATTR1}&#39;..&#39;{CUSTOM_ATTR3}&#39; is replaced by the respective custom attribute

    The returned data is only parsed by the DT_... classes.
    For the DT_json class, the read_data dict can be used to extract a specific
    element from a json response:

    ``read_data = {&#39;dict&#39;: [&#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;]}``

    would try to get

    ``json_response[&#39;key1&#39;][&#39;key2&#39;][&#39;key3&#39;]``

    and return it as the read value.

    This class is provided as a reference implementation for the Net-Connections.
    &#34;&#34;&#34;
    read_data = None

    def get_send_data(self, data, **kwargs):

        self._plugin_params.update(kwargs)
        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd, data, **kwargs)
            else:
                cmd_str = self._parse_str(self.opcode, data, **kwargs)
        else:
            # create write data
            if self.write_cmd:
                cmd_str = self._parse_str(self.write_cmd, data, **kwargs)
            else:
                cmd_str = self._parse_str(self.opcode, data, **kwargs)

        data_dict = {}
        data_dict[&#39;payload&#39;] = cmd_str
        for k in self._plugin_params.keys():
            data_dict[k] = self._parse_tree(self.params[k], data, **kwargs)

        return data_dict

    def get_shng_data(self, data, **kwargs):
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def _parse_str(self, string, data=None, **kwargs):
        &#34;&#34;&#34;
        parse string and replace
        - ``{OPCODE}`` with the command opcode
        - ``{PARAM:&lt;elem&gt;}`` with the plugin parameter
        - ``{VALUE}`` with the data value
        - ``{CUSTOM_ATTR[123]}`` with the respective custom token value

        The replacement order ensures that PARAM-patterns from the opcode
        can be replaced as well as VALUE-pattern in any of the strings.
        &#34;&#34;&#34;
        def repl_func(matchobj):
            return str(self._plugin_params.get(matchobj.group(2), &#39;&#39;))

        def cust_func(matchobj):
            if kwargs and &#39;custom&#39; in kwargs:
                return str(kwargs[&#39;custom&#39;].get(int(matchobj.group(2))))
            return &#39;&#39;

        string = string.replace(&#39;{&#39; + CMD_STR_OPCODE + &#39;}&#39;, self.opcode)

        regex = r&#39;(\{&#39; + CMD_STR_PARAM + r&#39;([^}]+)\})&#39;
        while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
            string = re.sub(regex, repl_func, string)

        regex = r&#39;(\{&#39; + CMD_STR_CUSTOM + r&#39;([123])\})&#39;
        while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
            string = re.sub(regex, cust_func, string)

        # if kwargs and ITEM_ATTR_CUSTOM_PREFIX in kwargs:
        #     regex = &#39;(MD_CUSTOM([123]))&#39;
        #     while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
        #         index = int(re.match(regex, string).group(2))
        #         if index in kwargs[ITEM_ATTR_CUSTOM_PREFIX]:
        #             string = re.sub(regex, kwargs[ITEM_ATTR_CUSTOM_PREFIX][index], string)

        if data is not None:
            string = string.replace(&#39;{&#39; + CMD_STR_VALUE + &#39;}&#39;, str(self._DT.get_send_data(data)))

        return string

    def _parse_tree(self, node, data, **kwargs):
        &#34;&#34;&#34;
        traverse node and
        - apply _parse_str to strings
        - recursively _parse_tree for all elements of iterables or
        - return unknown or unparseable elements unchanged
        &#34;&#34;&#34;
        if issubclass(node, str):
            return self._parse_str(node, data, **kwargs)
        elif issubclass(node, list):
            return [self._parse_tree(k, data, **kwargs) for k in node]
        elif issubclass(node, tuple):
            return (self._parse_tree(k, data, **kwargs) for k in node)
        elif issubclass(node, dict):
            new_dict = {}
            for k in node.keys():
                new_dict[k] = self._parse_tree(node[k], data, **kwargs)
            return new_dict
        else:
            return node


class MD_Command_ParseStr(MD_Command_Str):
    &#34;&#34;&#34; Command for string-based communication with parsed arguments

    With this class, you can simplify the creation of read and write commands
    containing data values.

    Default behaviour is identical to MD_Command_Str.

    opcode, write_cmd and read_cmd will be parsed to substitute values.
    write_cmd will be formatted, replacing ``{RAW_VALUE}`` with the value by
    using write_cmd.format(RAW_VALUE=data_dict[&#39;payload&#39;]), so you can
    immediately embed the value in the command string with configurable
    formatting conforming to str.format() syntax.
    Analogous to ``RAW_VALUE``, you can also use ``RAW_VALUE_UPPER``,
    ``RAW_VALUE_LOWER`` and ``RAW_VALUE_CAP`` for string values.

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; with one (1) match group will try and
    capture the matched group into the received value.

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; without capturing parentheses will return
    the reply value as is (can possibly be converted by the DT class).

    HINT: If you give reply_pattern as regex, the reply_pattern regex will be
    used to identify a reply as belonging to this command if a match is found.

    If the reply_pattern contains ``{LOOKUP}`` and lookup is set to a valid
    lookup table, the &#39;{MD_LOOKUP}&#39; identifier is replaced with a regex which
    triggers on any of the possible lookup values.
    The same applies for ``{VALID_LIST}`` and ``{VALID_LIST_CI}`` for the
    respective valid_lists from the command settings; including one of 
    ``{CUSTOM_PATTERN1}``...``{CUSTOM_PATTERN3}`` will replace these with the
    respective custom pattern from the device class.

    Some results can be achieved with customized DT_foo classes, but this
    might be an easier and cleaner solution. Please make sure to understand
    MRE by JF properly :)
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        self._plugin_params.update(kwargs)
        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd, data, **kwargs)
            else:
                cmd_str = self._parse_str(self.opcode, data, **kwargs)
        else:
            # create write data
            if self.write_cmd:
                cmd = self._parse_str(self.write_cmd, data, **kwargs)
            else:
                cmd = self._parse_str(self.opcode, data, **kwargs)

            # apply substitutions
            if isinstance(data, str):
                d = {CMD_STR_VAL_RAW: data,
                     CMD_STR_VAL_UPP: data.upper(),
                     CMD_STR_VAL_LOW: data.lower(),
                     CMD_STR_VAL_CAP: data.capitalize()}
                cmd_str = self._parse_str(cmd.format(**d), data)
            else:
                d = {CMD_STR_VAL_RAW: data}
                cmd_str = self._parse_str(cmd.format(**d), data)

        return {&#39;payload&#39;: cmd_str, &#39;data&#39;: None if data is None else self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        &#34;&#34;&#34;
        Try to match data to reply_pattern if reply_pattern is set.

        If a match is found and a value is captured, it will be returned.

        If a match is found without a capturing group, the value will be
        returned as-is, possibly to be converted by the DT class.

        If no match can be achieved, it is not possible to return
        a meaningful value. To signal the error, an exception will be raised.
        &#34;&#34;&#34;
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)

        self.logger.debug(f&#39;parse_str command got data {data} of type {type(data)}&#39;)

        if self.reply_pattern and isinstance(data, str):
            for pattern in self.reply_pattern:
                regex = re.compile(pattern)
                match = regex.search(data)
                if match:
                    if len(match.groups()) == 1:

                        # one captured group - ok
                        value = self._DT.get_shng_data(match.group(1), **kwargs)
                        break
                    elif len(match.groups()) &gt; 1:

                        # more than one captured group - error
                        raise ValueError(f&#39;reply_pattern {self.reply_pattern} has more than one pair of capturing parentheses&#39;)
                    else:

                        # no captured groups = no parentheses = no extraction of value, just do the &#34;normal&#34; thing
                        value = self._DT.get_shng_data(data, **kwargs)
                else:
                    raise ValueError(f&#39;reply_pattern {self.reply_pattern} could not get a match on {data}&#39;)
        else:
            value = self._DT.get_shng_data(data, **kwargs)
        return value


class MD_Command_JSON(MD_Command):
    &#34;&#34;&#34; Command for JSON-RPC communication

    With this class, you can send JSON-RPC commands to the device and read
    from it.

    The command is sent as JSON-RPC &#39;method&#39;, the params-dict is populated from
    the CMD_ATTR_PARAMS attribute of the command. &#39;{VALUE}&#39; (CMD_STR_VAL) is
    replaced with the actual item value.

    Giving &#39;playerid&#39; in kwargs replaces a dict entry with the key of &#39;playerid&#39;
    or a list entry of &#39;{ID}&#39; with the value of kwargs[&#39;playerid&#39;].

    params needs to be None or a dict.
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        cmd = None
        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode
        ddict = self._build_dict(self._DT.get_send_data(data), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data.get(&#39;result&#39;), **kwargs)
        return value

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        def check_value(val, data):

            if isinstance(val, list):
                # recursively check list
                for idx in range(len(val)):
                    val[idx] = check_value(val[idx], data)
            elif val == &#39;{&#39; + CMD_STR_VALUE + &#39;}&#39;:
                val = data
            elif &#39;custom&#39; in kwargs and isinstance(val, str) and re.match(r&#39;^\{CUSTOM_ATTR[123]\}$&#39;, val):
                idx = re.match(r&#39;^\{CUSTOM_ATTR([123])\}$&#39;, val)
                if idx and (1 &lt;= int(idx[1]) &lt;= 3):
                    val = kwargs[&#39;custom&#39;][int(idx[1])]
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;{&#39; + CMD_STR_VALUE + &#39;}&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            return val

        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        params = deepcopy(self.params)

        if isinstance(params, list):

            # unnamed parameters, list format
            for i in range(len(params)):
                params[i] = check_value(params[i], data)

                if params[i] == &#39;{ID}&#39; and &#39;playerid&#39; in kwargs:
                    params[i] = kwargs[&#39;playerid&#39;]

        elif isinstance(params, dict):

            # named parameters, dict format
            for key in params:
                params[key] = check_value(params[key], data)

            if &#39;playerid&#39; in params and &#39;playerid&#39; in kwargs:
                params[&#39;playerid&#39;] = kwargs[&#39;playerid&#39;]
        else:
            raise ValueError(&#39;invalid data: params not in dict or list format&#39;)

        return params


class MD_Command_Viessmann(MD_Command):
    &#34;&#34;&#34; Command for Viessmann binary command format

    With this class, you can send commands to Viessmann heating systems

    The command is sent as &#39;method&#39;, the params-dict is populated from the
    CMD_ATTR_PARAMS attribute of the command, while the parameter values are
    taken from the CMD_ATTR_PARAM_VALUES attribute. &#39;VAL&#39; is replaced with the
    actual item value.

    params and param_value need to be None or lists of the same length.
    &#34;&#34;&#34;
    def __init__(self, device_id, command, dt_class, **kwargs):
        super().__init__(device_id, command, dt_class, **kwargs)

        self._len = 1
        self._mult = 0
        self._signed = False
        for attr in (&#39;len&#39;, &#39;mult&#39;, &#39;signed&#39;):
            if attr in self.params:
                setattr(self, &#39;_&#39; + attr, self.params[attr])

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        ddict = self._build_dict(self._DT.get_send_data(data, len=self._len, mult=self._mult, signed=self._signed), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        params = {}
        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        for key in self.params:
            val = self.params[key]
            if val == &#39;VAL&#39;:
                val = data
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;VAL&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            params[key] = val

        return params</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multidevice.MD_Command.MD_Command"><code class="flex name class">
<span>class <span class="ident">MD_Command</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MD_Command class for command data handling</p>
<p>This class represents a general command that uses read_cmd/write_cmd or, if
not present, opcode as payload for the connection. Data is supplied in the
'data'-key values in the data_dict. DT type conversion is applied with default
values.</p>
<p>For attributes defined in commands.py, see explanation in the
dev_example/commands.py file.</p>
<p>This class serves as a base class for further format-specific command types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command(object):
    &#34;&#34;&#34; MD_Command class for command data handling

    This class represents a general command that uses read_cmd/write_cmd or, if
    not present, opcode as payload for the connection. Data is supplied in the
    &#39;data&#39;-key values in the data_dict. DT type conversion is applied with default
    values.

    For attributes defined in commands.py, see explanation in the
    dev_example/commands.py file.

    This class serves as a base class for further format-specific command types.
    &#34;&#34;&#34;
    device_id = &#39;&#39;
    name = &#39;&#39;
    opcode = &#39;&#39;
    read = False
    write = False
    read_cmd = None
    write_cmd = None
    item_type = None
    reply_token = []
    reply_pattern = &#39;&#39;
    cmd_settings = None
    lookup = None
    _DT = None

    def __init__(self, device_id, command, dt_class, **kwargs):

        # get MultiDevice.device logger (if not already defined by derived class calling us via super().__init__())
        if not hasattr(self, &#39;logger&#39;):
            self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if not device_id:
            self.logger.warning(f&#39;building command {command} without a device, aborting&#39;)
        else:
            self.device_id = device_id

        if not command:
            self.logger.warning(&#39;building command without a name, aborting&#39;)
            return
        else:
            self.name = command

        kw = kwargs[&#39;cmd&#39;]
        self._plugin_params = kwargs[&#39;plugin&#39;]

        self._get_kwargs(COMMAND_PARAMS, **kw)

        try:
            self._DT = dt_class()
        except Exception as e:
            self.logger.error(f&#39;building command {command} failed on instantiating datatype class {dt_class}. Error was: {e}&#39;)
            self._DT = DT.DT_raw()

        # only log if base class. Derived classes log their own messages
        if self.__class__ is MD_Command:
            self.logger.debug(f&#39;learned command {command} with device datatype {dt_class} in {self.__class__.__name__}&#39;)

    def get_send_data(self, data, **kwargs):

        cmd = None

        data = self._check_value(data)

        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        return {&#39;payload&#39;: cmd, &#39;data&#39;: self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def get_lookup(self):
        &#34;&#34;&#34; getter for lookup &#34;&#34;&#34;
        return self.lookup

    def _get_kwargs(self, args, **kwargs):
        &#34;&#34;&#34;
        check if any items from args is present in kwargs and set the class property
        of the same name to its value.

        :param args: list or tuple of parameter names
        :type args: list | tuple
        &#34;&#34;&#34;
        for arg in args:
            if kwargs.get(arg, None):
                setattr(self, arg, kwargs[arg])

    def _check_min_max(self, data, key, min=True, force=False):
        &#34;&#34;&#34; helper routine to check for min/max compliance and int/float type &#34;&#34;&#34;
        if key in self.cmd_settings:
            bound = self.cmd_settings[key]
            if not isinstance(data, type(bound)):
                if type(data) is float and type(bound) is int:
                    data = int(data)
                elif type(data) is int and type(bound) is float:
                    data = float(data)
                else:
                    raise ValueError(f&#39;type {type(data)} ({data}) given for {type(bound)} ({bound})&#39;)
            if (min and data &gt;= bound) or (not min and data &lt;= bound):
                return data
            if force:
                self.logger.debug(f&#39;Value {data} changed to {bound} due to cmd_settings {self.cmd_settings}&#39;)
                return bound
            raise ValueError(f&#39;value {data} not adhering to {&#34;min&#34; if min else &#34;max&#34;} value {bound}&#39;)
        return data

    def _check_value(self, data):
        &#34;&#34;&#34;
        check if value settings are defined and if so, if they are followed
        possibly adjust data in accordance with settings

        non-compliance will raise ValueError

        This can be overwritten; make sure to call
        data = super()._check_value(data)
        to run this code in addition to your own extension, if applicable.
        Take care of the sequence of changing data, though...

        :param data: data/value to send
        :return: adjusted data
        &#34;&#34;&#34;
        if data is not None:
            try:
                if self.cmd_settings and not self.lookup:
                    if self.cmd_settings.get(&#39;valid_list_ci&#39;, None):
                        val = data
                        if isinstance(data, str):
                            val = data.lower()
                        if val not in self.cmd_settings[&#39;valid_list_ci&#39;]:
                            raise ValueError(f&#39;value {val} not in case insensitive list {self.cmd_settings[&#34;valid_list_ci&#34;]}&#39;)
                    elif self.cmd_settings.get(&#39;valid_list&#39;, None):
                        if data not in self.cmd_settings[&#39;valid_list&#39;]:
                            raise ValueError(f&#39;value {data} not in list {self.cmd_settings[&#34;valid_list&#34;]}&#39;)
                    # min/max not in addition to valid_list
                    elif any(key in self.cmd_settings.keys() for key in MINMAXKEYS):
                        for key in MINMAXKEYS:
                            data = self._check_min_max(data, key, key[-3:] == &#39;min&#39;, key[:5] == &#39;force&#39;)

            except Exception as e:
                raise ValueError(f&#39;Given invalid value for command {self.name} due to settings. Error was: {e}&#39;)

        return data</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command_JSON" href="#multidevice.MD_Command.MD_Command_JSON">MD_Command_JSON</a></li>
<li><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></li>
<li><a title="multidevice.MD_Command.MD_Command_Viessmann" href="#multidevice.MD_Command.MD_Command_Viessmann">MD_Command_Viessmann</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command.cmd_settings"><code class="name">var <span class="ident">cmd_settings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.device_id"><code class="name">var <span class="ident">device_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.item_type"><code class="name">var <span class="ident">item_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.lookup"><code class="name">var <span class="ident">lookup</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.opcode"><code class="name">var <span class="ident">opcode</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.read"><code class="name">var <span class="ident">read</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.read_cmd"><code class="name">var <span class="ident">read_cmd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.reply_pattern"><code class="name">var <span class="ident">reply_pattern</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.reply_token"><code class="name">var <span class="ident">reply_token</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.write"><code class="name">var <span class="ident">write</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.write_cmd"><code class="name">var <span class="ident">write_cmd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command.get_lookup"><code class="name flex">
<span>def <span class="ident">get_lookup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getter for lookup</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lookup(self):
    &#34;&#34;&#34; getter for lookup &#34;&#34;&#34;
    return self.lookup</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    cmd = None

    data = self._check_value(data)

    # create read data
    if data is None:
        if self.read_cmd:
            cmd = self.read_cmd
        else:
            cmd = self.opcode
    else:
        if self.write_cmd:
            cmd = self.write_cmd
        else:
            cmd = self.opcode

    return {&#39;payload&#39;: cmd, &#39;data&#39;: self._DT.get_send_data(data)}</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    value = self._DT.get_shng_data(data, **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multidevice.MD_Command.MD_Command_JSON"><code class="flex name class">
<span>class <span class="ident">MD_Command_JSON</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for JSON-RPC communication</p>
<p>With this class, you can send JSON-RPC commands to the device and read
from it.</p>
<p>The command is sent as JSON-RPC 'method', the params-dict is populated from
the CMD_ATTR_PARAMS attribute of the command. '{VALUE}' (CMD_STR_VAL) is
replaced with the actual item value.</p>
<p>Giving 'playerid' in kwargs replaces a dict entry with the key of 'playerid'
or a list entry of '{ID}' with the value of kwargs['playerid'].</p>
<p>params needs to be None or a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_JSON(MD_Command):
    &#34;&#34;&#34; Command for JSON-RPC communication

    With this class, you can send JSON-RPC commands to the device and read
    from it.

    The command is sent as JSON-RPC &#39;method&#39;, the params-dict is populated from
    the CMD_ATTR_PARAMS attribute of the command. &#39;{VALUE}&#39; (CMD_STR_VAL) is
    replaced with the actual item value.

    Giving &#39;playerid&#39; in kwargs replaces a dict entry with the key of &#39;playerid&#39;
    or a list entry of &#39;{ID}&#39; with the value of kwargs[&#39;playerid&#39;].

    params needs to be None or a dict.
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        cmd = None
        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode
        ddict = self._build_dict(self._DT.get_send_data(data), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data.get(&#39;result&#39;), **kwargs)
        return value

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        def check_value(val, data):

            if isinstance(val, list):
                # recursively check list
                for idx in range(len(val)):
                    val[idx] = check_value(val[idx], data)
            elif val == &#39;{&#39; + CMD_STR_VALUE + &#39;}&#39;:
                val = data
            elif &#39;custom&#39; in kwargs and isinstance(val, str) and re.match(r&#39;^\{CUSTOM_ATTR[123]\}$&#39;, val):
                idx = re.match(r&#39;^\{CUSTOM_ATTR([123])\}$&#39;, val)
                if idx and (1 &lt;= int(idx[1]) &lt;= 3):
                    val = kwargs[&#39;custom&#39;][int(idx[1])]
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;{&#39; + CMD_STR_VALUE + &#39;}&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            return val

        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        params = deepcopy(self.params)

        if isinstance(params, list):

            # unnamed parameters, list format
            for i in range(len(params)):
                params[i] = check_value(params[i], data)

                if params[i] == &#39;{ID}&#39; and &#39;playerid&#39; in kwargs:
                    params[i] = kwargs[&#39;playerid&#39;]

        elif isinstance(params, dict):

            # named parameters, dict format
            for key in params:
                params[key] = check_value(params[key], data)

            if &#39;playerid&#39; in params and &#39;playerid&#39; in kwargs:
                params[&#39;playerid&#39;] = kwargs[&#39;playerid&#39;]
        else:
            raise ValueError(&#39;invalid data: params not in dict or list format&#39;)

        return params</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_JSON.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    cmd = None
    data = self._check_value(data)
    # create read data
    if data is None:
        if self.read_cmd:
            cmd = self.read_cmd
        else:
            cmd = self.opcode
    else:
        if self.write_cmd:
            cmd = self.write_cmd
        else:
            cmd = self.opcode
    ddict = self._build_dict(self._DT.get_send_data(data), **kwargs)
    return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command_JSON.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    value = self._DT.get_shng_data(data.get(&#39;result&#39;), **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Command.MD_Command_ParseStr"><code class="flex name class">
<span>class <span class="ident">MD_Command_ParseStr</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for string-based communication with parsed arguments</p>
<p>With this class, you can simplify the creation of read and write commands
containing data values.</p>
<p>Default behaviour is identical to MD_Command_Str.</p>
<p>opcode, write_cmd and read_cmd will be parsed to substitute values.
write_cmd will be formatted, replacing <code>{RAW_VALUE}</code> with the value by
using write_cmd.format(RAW_VALUE=data_dict['payload']), so you can
immediately embed the value in the command string with configurable
formatting conforming to str.format() syntax.
Analogous to <code>RAW_VALUE</code>, you can also use <code>RAW_VALUE_UPPER</code>,
<code>RAW_VALUE_LOWER</code> and <code>RAW_VALUE_CAP</code> for string values.</p>
<p>Giving reply_pattern as '<regex>' with one (1) match group will try and
capture the matched group into the received value.</p>
<p>Giving reply_pattern as '<regex>' without capturing parentheses will return
the reply value as is (can possibly be converted by the DT class).</p>
<p>HINT: If you give reply_pattern as regex, the reply_pattern regex will be
used to identify a reply as belonging to this command if a match is found.</p>
<p>If the reply_pattern contains <code>{LOOKUP}</code> and lookup is set to a valid
lookup table, the '{MD_LOOKUP}' identifier is replaced with a regex which
triggers on any of the possible lookup values.
The same applies for <code>{VALID_LIST}</code> and <code>{VALID_LIST_CI}</code> for the
respective valid_lists from the command settings; including one of
<code>{CUSTOM_PATTERN1}</code>&hellip;<code>{CUSTOM_PATTERN3}</code> will replace these with the
respective custom pattern from the device class.</p>
<p>Some results can be achieved with customized DT_foo classes, but this
might be an easier and cleaner solution. Please make sure to understand
MRE by JF properly :)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_ParseStr(MD_Command_Str):
    &#34;&#34;&#34; Command for string-based communication with parsed arguments

    With this class, you can simplify the creation of read and write commands
    containing data values.

    Default behaviour is identical to MD_Command_Str.

    opcode, write_cmd and read_cmd will be parsed to substitute values.
    write_cmd will be formatted, replacing ``{RAW_VALUE}`` with the value by
    using write_cmd.format(RAW_VALUE=data_dict[&#39;payload&#39;]), so you can
    immediately embed the value in the command string with configurable
    formatting conforming to str.format() syntax.
    Analogous to ``RAW_VALUE``, you can also use ``RAW_VALUE_UPPER``,
    ``RAW_VALUE_LOWER`` and ``RAW_VALUE_CAP`` for string values.

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; with one (1) match group will try and
    capture the matched group into the received value.

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; without capturing parentheses will return
    the reply value as is (can possibly be converted by the DT class).

    HINT: If you give reply_pattern as regex, the reply_pattern regex will be
    used to identify a reply as belonging to this command if a match is found.

    If the reply_pattern contains ``{LOOKUP}`` and lookup is set to a valid
    lookup table, the &#39;{MD_LOOKUP}&#39; identifier is replaced with a regex which
    triggers on any of the possible lookup values.
    The same applies for ``{VALID_LIST}`` and ``{VALID_LIST_CI}`` for the
    respective valid_lists from the command settings; including one of 
    ``{CUSTOM_PATTERN1}``...``{CUSTOM_PATTERN3}`` will replace these with the
    respective custom pattern from the device class.

    Some results can be achieved with customized DT_foo classes, but this
    might be an easier and cleaner solution. Please make sure to understand
    MRE by JF properly :)
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        self._plugin_params.update(kwargs)
        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd, data, **kwargs)
            else:
                cmd_str = self._parse_str(self.opcode, data, **kwargs)
        else:
            # create write data
            if self.write_cmd:
                cmd = self._parse_str(self.write_cmd, data, **kwargs)
            else:
                cmd = self._parse_str(self.opcode, data, **kwargs)

            # apply substitutions
            if isinstance(data, str):
                d = {CMD_STR_VAL_RAW: data,
                     CMD_STR_VAL_UPP: data.upper(),
                     CMD_STR_VAL_LOW: data.lower(),
                     CMD_STR_VAL_CAP: data.capitalize()}
                cmd_str = self._parse_str(cmd.format(**d), data)
            else:
                d = {CMD_STR_VAL_RAW: data}
                cmd_str = self._parse_str(cmd.format(**d), data)

        return {&#39;payload&#39;: cmd_str, &#39;data&#39;: None if data is None else self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        &#34;&#34;&#34;
        Try to match data to reply_pattern if reply_pattern is set.

        If a match is found and a value is captured, it will be returned.

        If a match is found without a capturing group, the value will be
        returned as-is, possibly to be converted by the DT class.

        If no match can be achieved, it is not possible to return
        a meaningful value. To signal the error, an exception will be raised.
        &#34;&#34;&#34;
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)

        self.logger.debug(f&#39;parse_str command got data {data} of type {type(data)}&#39;)

        if self.reply_pattern and isinstance(data, str):
            for pattern in self.reply_pattern:
                regex = re.compile(pattern)
                match = regex.search(data)
                if match:
                    if len(match.groups()) == 1:

                        # one captured group - ok
                        value = self._DT.get_shng_data(match.group(1), **kwargs)
                        break
                    elif len(match.groups()) &gt; 1:

                        # more than one captured group - error
                        raise ValueError(f&#39;reply_pattern {self.reply_pattern} has more than one pair of capturing parentheses&#39;)
                    else:

                        # no captured groups = no parentheses = no extraction of value, just do the &#34;normal&#34; thing
                        value = self._DT.get_shng_data(data, **kwargs)
                else:
                    raise ValueError(f&#39;reply_pattern {self.reply_pattern} could not get a match on {data}&#39;)
        else:
            value = self._DT.get_shng_data(data, **kwargs)
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></li>
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_ParseStr.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    self._plugin_params.update(kwargs)
    data = self._check_value(data)

    if data is None:
        # create read data
        if self.read_cmd:
            cmd_str = self._parse_str(self.read_cmd, data, **kwargs)
        else:
            cmd_str = self._parse_str(self.opcode, data, **kwargs)
    else:
        # create write data
        if self.write_cmd:
            cmd = self._parse_str(self.write_cmd, data, **kwargs)
        else:
            cmd = self._parse_str(self.opcode, data, **kwargs)

        # apply substitutions
        if isinstance(data, str):
            d = {CMD_STR_VAL_RAW: data,
                 CMD_STR_VAL_UPP: data.upper(),
                 CMD_STR_VAL_LOW: data.lower(),
                 CMD_STR_VAL_CAP: data.capitalize()}
            cmd_str = self._parse_str(cmd.format(**d), data)
        else:
            d = {CMD_STR_VAL_RAW: data}
            cmd_str = self._parse_str(cmd.format(**d), data)

    return {&#39;payload&#39;: cmd_str, &#39;data&#39;: None if data is None else self._DT.get_send_data(data)}</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command_ParseStr.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to match data to reply_pattern if reply_pattern is set.</p>
<p>If a match is found and a value is captured, it will be returned.</p>
<p>If a match is found without a capturing group, the value will be
returned as-is, possibly to be converted by the DT class.</p>
<p>If no match can be achieved, it is not possible to return
a meaningful value. To signal the error, an exception will be raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    &#34;&#34;&#34;
    Try to match data to reply_pattern if reply_pattern is set.

    If a match is found and a value is captured, it will be returned.

    If a match is found without a capturing group, the value will be
    returned as-is, possibly to be converted by the DT class.

    If no match can be achieved, it is not possible to return
    a meaningful value. To signal the error, an exception will be raised.
    &#34;&#34;&#34;
    if isinstance(data, (bytes, bytearray)):
        data = data.decode(&#39;utf-8&#39;)

    self.logger.debug(f&#39;parse_str command got data {data} of type {type(data)}&#39;)

    if self.reply_pattern and isinstance(data, str):
        for pattern in self.reply_pattern:
            regex = re.compile(pattern)
            match = regex.search(data)
            if match:
                if len(match.groups()) == 1:

                    # one captured group - ok
                    value = self._DT.get_shng_data(match.group(1), **kwargs)
                    break
                elif len(match.groups()) &gt; 1:

                    # more than one captured group - error
                    raise ValueError(f&#39;reply_pattern {self.reply_pattern} has more than one pair of capturing parentheses&#39;)
                else:

                    # no captured groups = no parentheses = no extraction of value, just do the &#34;normal&#34; thing
                    value = self._DT.get_shng_data(data, **kwargs)
            else:
                raise ValueError(f&#39;reply_pattern {self.reply_pattern} could not get a match on {data}&#39;)
    else:
        value = self._DT.get_shng_data(data, **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command_Str.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Command.MD_Command_Str"><code class="flex name class">
<span>class <span class="ident">MD_Command_Str</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for string-based communication</p>
<p>This class represents a command which uses a string with arguments as payload,
for example as query URL.</p>
<p>Default behaviour is identical to MD_Command.</p>
<p>For sending, the read_cmd/write_cmd strings, opcode and data are parsed
(recursively), to enable the following parameters:</p>
<ul>
<li>'{OPCODE}' is replaced with the opcode,</li>
<li>'{PARAM:attr}' is replaced with the value of the attr element from the plugin configuration,</li>
<li>'{VALUE}' is replaced with the given value (converted by DT-class)</li>
<li>'{CUSTOM_ATTR1}'..'{CUSTOM_ATTR3}' is replaced by the respective custom attribute</li>
</ul>
<p>The returned data is only parsed by the DT_&hellip; classes.
For the DT_json class, the read_data dict can be used to extract a specific
element from a json response:</p>
<p><code>read_data = {'dict': ['key1', 'key2', 'key3']}</code></p>
<p>would try to get</p>
<p><code>json_response['key1']['key2']['key3']</code></p>
<p>and return it as the read value.</p>
<p>This class is provided as a reference implementation for the Net-Connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_Str(MD_Command):
    &#34;&#34;&#34; Command for string-based communication

    This class represents a command which uses a string with arguments as payload,
    for example as query URL.

    Default behaviour is identical to MD_Command.

    For sending, the read_cmd/write_cmd strings, opcode and data are parsed
    (recursively), to enable the following parameters:

    - &#39;{OPCODE}&#39; is replaced with the opcode,
    - &#39;{PARAM:attr}&#39; is replaced with the value of the attr element from the plugin configuration,
    - &#39;{VALUE}&#39; is replaced with the given value (converted by DT-class)
    - &#39;{CUSTOM_ATTR1}&#39;..&#39;{CUSTOM_ATTR3}&#39; is replaced by the respective custom attribute

    The returned data is only parsed by the DT_... classes.
    For the DT_json class, the read_data dict can be used to extract a specific
    element from a json response:

    ``read_data = {&#39;dict&#39;: [&#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;]}``

    would try to get

    ``json_response[&#39;key1&#39;][&#39;key2&#39;][&#39;key3&#39;]``

    and return it as the read value.

    This class is provided as a reference implementation for the Net-Connections.
    &#34;&#34;&#34;
    read_data = None

    def get_send_data(self, data, **kwargs):

        self._plugin_params.update(kwargs)
        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd, data, **kwargs)
            else:
                cmd_str = self._parse_str(self.opcode, data, **kwargs)
        else:
            # create write data
            if self.write_cmd:
                cmd_str = self._parse_str(self.write_cmd, data, **kwargs)
            else:
                cmd_str = self._parse_str(self.opcode, data, **kwargs)

        data_dict = {}
        data_dict[&#39;payload&#39;] = cmd_str
        for k in self._plugin_params.keys():
            data_dict[k] = self._parse_tree(self.params[k], data, **kwargs)

        return data_dict

    def get_shng_data(self, data, **kwargs):
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def _parse_str(self, string, data=None, **kwargs):
        &#34;&#34;&#34;
        parse string and replace
        - ``{OPCODE}`` with the command opcode
        - ``{PARAM:&lt;elem&gt;}`` with the plugin parameter
        - ``{VALUE}`` with the data value
        - ``{CUSTOM_ATTR[123]}`` with the respective custom token value

        The replacement order ensures that PARAM-patterns from the opcode
        can be replaced as well as VALUE-pattern in any of the strings.
        &#34;&#34;&#34;
        def repl_func(matchobj):
            return str(self._plugin_params.get(matchobj.group(2), &#39;&#39;))

        def cust_func(matchobj):
            if kwargs and &#39;custom&#39; in kwargs:
                return str(kwargs[&#39;custom&#39;].get(int(matchobj.group(2))))
            return &#39;&#39;

        string = string.replace(&#39;{&#39; + CMD_STR_OPCODE + &#39;}&#39;, self.opcode)

        regex = r&#39;(\{&#39; + CMD_STR_PARAM + r&#39;([^}]+)\})&#39;
        while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
            string = re.sub(regex, repl_func, string)

        regex = r&#39;(\{&#39; + CMD_STR_CUSTOM + r&#39;([123])\})&#39;
        while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
            string = re.sub(regex, cust_func, string)

        # if kwargs and ITEM_ATTR_CUSTOM_PREFIX in kwargs:
        #     regex = &#39;(MD_CUSTOM([123]))&#39;
        #     while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
        #         index = int(re.match(regex, string).group(2))
        #         if index in kwargs[ITEM_ATTR_CUSTOM_PREFIX]:
        #             string = re.sub(regex, kwargs[ITEM_ATTR_CUSTOM_PREFIX][index], string)

        if data is not None:
            string = string.replace(&#39;{&#39; + CMD_STR_VALUE + &#39;}&#39;, str(self._DT.get_send_data(data)))

        return string

    def _parse_tree(self, node, data, **kwargs):
        &#34;&#34;&#34;
        traverse node and
        - apply _parse_str to strings
        - recursively _parse_tree for all elements of iterables or
        - return unknown or unparseable elements unchanged
        &#34;&#34;&#34;
        if issubclass(node, str):
            return self._parse_str(node, data, **kwargs)
        elif issubclass(node, list):
            return [self._parse_tree(k, data, **kwargs) for k in node]
        elif issubclass(node, tuple):
            return (self._parse_tree(k, data, **kwargs) for k in node)
        elif issubclass(node, dict):
            new_dict = {}
            for k in node.keys():
                new_dict[k] = self._parse_tree(node[k], data, **kwargs)
            return new_dict
        else:
            return node</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command_ParseStr" href="#multidevice.MD_Command.MD_Command_ParseStr">MD_Command_ParseStr</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_Str.read_data"><code class="name">var <span class="ident">read_data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_Str.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    self._plugin_params.update(kwargs)
    data = self._check_value(data)

    if data is None:
        # create read data
        if self.read_cmd:
            cmd_str = self._parse_str(self.read_cmd, data, **kwargs)
        else:
            cmd_str = self._parse_str(self.opcode, data, **kwargs)
    else:
        # create write data
        if self.write_cmd:
            cmd_str = self._parse_str(self.write_cmd, data, **kwargs)
        else:
            cmd_str = self._parse_str(self.opcode, data, **kwargs)

    data_dict = {}
    data_dict[&#39;payload&#39;] = cmd_str
    for k in self._plugin_params.keys():
        data_dict[k] = self._parse_tree(self.params[k], data, **kwargs)

    return data_dict</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command_Str.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    if isinstance(data, (bytes, bytearray)):
        data = data.decode(&#39;utf-8&#39;)
    value = self._DT.get_shng_data(data, **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Command.MD_Command_Viessmann"><code class="flex name class">
<span>class <span class="ident">MD_Command_Viessmann</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for Viessmann binary command format</p>
<p>With this class, you can send commands to Viessmann heating systems</p>
<p>The command is sent as 'method', the params-dict is populated from the
CMD_ATTR_PARAMS attribute of the command, while the parameter values are
taken from the CMD_ATTR_PARAM_VALUES attribute. 'VAL' is replaced with the
actual item value.</p>
<p>params and param_value need to be None or lists of the same length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_Viessmann(MD_Command):
    &#34;&#34;&#34; Command for Viessmann binary command format

    With this class, you can send commands to Viessmann heating systems

    The command is sent as &#39;method&#39;, the params-dict is populated from the
    CMD_ATTR_PARAMS attribute of the command, while the parameter values are
    taken from the CMD_ATTR_PARAM_VALUES attribute. &#39;VAL&#39; is replaced with the
    actual item value.

    params and param_value need to be None or lists of the same length.
    &#34;&#34;&#34;
    def __init__(self, device_id, command, dt_class, **kwargs):
        super().__init__(device_id, command, dt_class, **kwargs)

        self._len = 1
        self._mult = 0
        self._signed = False
        for attr in (&#39;len&#39;, &#39;mult&#39;, &#39;signed&#39;):
            if attr in self.params:
                setattr(self, &#39;_&#39; + attr, self.params[attr])

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        ddict = self._build_dict(self._DT.get_send_data(data, len=self._len, mult=self._mult, signed=self._signed), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        params = {}
        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        for key in self.params:
            val = self.params[key]
            if val == &#39;VAL&#39;:
                val = data
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;VAL&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            params[key] = val

        return params</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_Viessmann.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    data = self._check_value(data)
    # create read data
    if data is None:
        if self.read_cmd:
            cmd = self.read_cmd
        else:
            cmd = self.opcode
    else:
        if self.write_cmd:
            cmd = self.write_cmd
        else:
            cmd = self.opcode

    ddict = self._build_dict(self._DT.get_send_data(data, len=self._len, mult=self._mult, signed=self._signed), **kwargs)
    return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multidevice" href="index.html">multidevice</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></code></h4>
<ul class="two-column">
<li><code><a title="multidevice.MD_Command.MD_Command.cmd_settings" href="#multidevice.MD_Command.MD_Command.cmd_settings">cmd_settings</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.device_id" href="#multidevice.MD_Command.MD_Command.device_id">device_id</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.get_send_data" href="#multidevice.MD_Command.MD_Command.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.get_shng_data" href="#multidevice.MD_Command.MD_Command.get_shng_data">get_shng_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.item_type" href="#multidevice.MD_Command.MD_Command.item_type">item_type</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.lookup" href="#multidevice.MD_Command.MD_Command.lookup">lookup</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.name" href="#multidevice.MD_Command.MD_Command.name">name</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.opcode" href="#multidevice.MD_Command.MD_Command.opcode">opcode</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.read" href="#multidevice.MD_Command.MD_Command.read">read</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.read_cmd" href="#multidevice.MD_Command.MD_Command.read_cmd">read_cmd</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.reply_pattern" href="#multidevice.MD_Command.MD_Command.reply_pattern">reply_pattern</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.reply_token" href="#multidevice.MD_Command.MD_Command.reply_token">reply_token</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.write" href="#multidevice.MD_Command.MD_Command.write">write</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.write_cmd" href="#multidevice.MD_Command.MD_Command.write_cmd">write_cmd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_JSON" href="#multidevice.MD_Command.MD_Command_JSON">MD_Command_JSON</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_JSON.get_send_data" href="#multidevice.MD_Command.MD_Command_JSON.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_JSON.get_shng_data" href="#multidevice.MD_Command.MD_Command_JSON.get_shng_data">get_shng_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_ParseStr" href="#multidevice.MD_Command.MD_Command_ParseStr">MD_Command_ParseStr</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_ParseStr.get_send_data" href="#multidevice.MD_Command.MD_Command_ParseStr.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_ParseStr.get_shng_data" href="#multidevice.MD_Command.MD_Command_ParseStr.get_shng_data">get_shng_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_Str.get_send_data" href="#multidevice.MD_Command.MD_Command_Str.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_Str.get_shng_data" href="#multidevice.MD_Command.MD_Command_Str.get_shng_data">get_shng_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_Str.read_data" href="#multidevice.MD_Command.MD_Command_Str.read_data">read_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_Viessmann" href="#multidevice.MD_Command.MD_Command_Viessmann">MD_Command_Viessmann</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_Viessmann.get_send_data" href="#multidevice.MD_Command.MD_Command_Viessmann.get_send_data">get_send_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>