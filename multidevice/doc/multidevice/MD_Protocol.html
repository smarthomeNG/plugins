<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>multidevice.MD_Protocol API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multidevice.MD_Protocol</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# vim: set encoding=utf-8 tabstop=4 softtabstop=4 shiftwidth=4 expandtab
#########################################################################
#  Copyright 2020-      Sebastian Helms             Morg @ knx-user-forum
#########################################################################
#  This file aims to become part of SmartHomeNG.
#  https://www.smarthomeNG.de
#  https://knx-user-forum.de/forum/supportforen/smarthome-py
#
#  MD_Protocol and derived classes for MultiDevice plugin
#
#  SmartHomeNG is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  SmartHomeNG is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with SmartHomeNG. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#########################################################################

import logging

if MD_standalone:
    from MD_Globals import (CONN_NET_TCP_CLI, CONN_SER_DIR, JSON_MOVE_KEYS, PLUGIN_ATTR_CB_ON_CONNECT, PLUGIN_ATTR_CB_ON_DISCONNECT, PLUGIN_ATTR_CONNECTION, PLUGIN_ATTR_CONN_AUTO_CONN, PLUGIN_ATTR_CONN_BINARY, PLUGIN_ATTR_CONN_CYCLE, PLUGIN_ATTR_CONN_RETRIES, PLUGIN_ATTR_CONN_TIMEOUT, PLUGIN_ATTR_MSG_REPEAT, PLUGIN_ATTR_MSG_TIMEOUT, PLUGIN_ATTR_NET_HOST, PLUGIN_ATTR_NET_PORT, PLUGIN_ATTR_SERIAL_BAUD, PLUGIN_ATTR_SERIAL_BSIZE, PLUGIN_ATTR_SERIAL_PARITY, PLUGIN_ATTR_SERIAL_PORT, PLUGIN_ATTR_SERIAL_STOP, REQUEST_DICT_ARGS)
    from MD_Connection import MD_Connection
else:
    from .MD_Globals import (CONN_NET_TCP_CLI, CONN_SER_DIR, JSON_MOVE_KEYS, PLUGIN_ATTR_CB_ON_CONNECT, PLUGIN_ATTR_CB_ON_DISCONNECT, PLUGIN_ATTR_CONNECTION, PLUGIN_ATTR_CONN_AUTO_CONN, PLUGIN_ATTR_CONN_BINARY, PLUGIN_ATTR_CONN_CYCLE, PLUGIN_ATTR_CONN_RETRIES, PLUGIN_ATTR_CONN_TIMEOUT, PLUGIN_ATTR_MSG_REPEAT, PLUGIN_ATTR_MSG_TIMEOUT, PLUGIN_ATTR_NET_HOST, PLUGIN_ATTR_NET_PORT, PLUGIN_ATTR_SERIAL_BAUD, PLUGIN_ATTR_SERIAL_BSIZE, PLUGIN_ATTR_SERIAL_PARITY, PLUGIN_ATTR_SERIAL_PORT, PLUGIN_ATTR_SERIAL_STOP, REQUEST_DICT_ARGS)
    from .MD_Connection import MD_Connection


from collections import OrderedDict
from time import time, sleep
import threading
import queue
import json


#############################################################################################################################################################################################################################################
#
# class MD_Protocol and subclasses
#
#############################################################################################################################################################################################################################################

class MD_Protocol(MD_Connection):
    &#34;&#34;&#34; MD_Protocol class to provide protocol support for MD_Device

    This class implements a basic protocol layer to act as a standin between
    the MD_Device-class and the MD_Connection-class. Its purpose is to enable
    establishing a control layer, so the connection only has to care for the
    &#39;physical&#39; connection and the device only needs to operate on commmand basis.

    This implementation can also be seen as a &#39;NULL&#39; protocol, it only passes
    along everything.

    By overwriting this class, different protocols can be implemented independent
    of the device and the connection classes.
    &#34;&#34;&#34;

    def __init__(self, device_type, device_id, data_received_callback, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if MD_standalone:
            self.logger = logging.getLogger(&#39;__main__&#39;)

        self.logger.debug(f&#39;protocol initializing from {self.__class__.__name__} with arguments {kwargs}&#39;)

        # set class properties
        self.device_type = device_type
        self.device_id = device_id
        self._is_connected = False
        self._data_received_callback = data_received_callback

        # make sure we have a basic set of parameters
        self._params = {PLUGIN_ATTR_CB_ON_DISCONNECT: None,
                        PLUGIN_ATTR_CB_ON_CONNECT: None,
                        PLUGIN_ATTR_MSG_TIMEOUT: 3,
                        PLUGIN_ATTR_MSG_REPEAT: 3,
                        PLUGIN_ATTR_CONNECTION: MD_Connection}
        self._params.update(kwargs)

        # check if some of the arguments are usable
        self._set_connection_params()

        # initialize connection
        conn_params = self._params.copy()
        conn_params.update({PLUGIN_ATTR_CB_ON_CONNECT: self.on_connect, PLUGIN_ATTR_CB_ON_DISCONNECT: self.on_disconnect})
        self._connection = self._params[PLUGIN_ATTR_CONNECTION](device_type, device_id, self.on_data_received, **conn_params)

        # tell someone about our actual class
        self.logger.debug(f&#39;protocol initialized from {self.__class__.__name__}&#39;)

    def _open(self):
        self.logger.debug(f&#39;{self.__class__.__name__} _open called, opening protocol with params {self._params}&#39;)
        if not self._connection.connected():
            self._connection.open()

        self._is_connected = self._connection.connected()
        return self._is_connected

    def _close(self):
        self.logger.debug(f&#39;{self.__class__.__name__} _close called, closing protocol&#39;)
        self._connection.close()
        self._is_connected = False

    def _send(self, data_dict):
        self.logger.debug(f&#39;{self.__class__.__name__} _send called with {data_dict}&#39;)
        return self._connection.send(data_dict)


class MD_Protocol_Jsonrpc(MD_Protocol):
    &#34;&#34;&#34; Protocol support for JSON-RPC 2.0

    This class implements a protocol to send JSONRPC 2.0  compatible messages
    As JSONRPC includes message-ids, replies can be associated to their respective
    queries and reply tracing and command repeat functions are implemented.

    Data received is dispatched via callback, thus the send()-method does not
    return any response data.

    Callback syntax is:
        def connected_callback(by=None)
        def disconnected_callback(by=None)
        def data_received_callback(by, message, command=None)
    If callbacks are class members, they need the additional first parameter &#39;self&#39;

    :param device_type: device type as used in commands.py name
    :param device_id: device id for use in item configuration and logs
    :type device_type: str
    :type device_id: str
    &#34;&#34;&#34;
    def __init__(self, device_type, device_id, data_received_callback, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if MD_standalone:
            self.logger = logging.getLogger(&#39;__main__&#39;)

        self.logger.debug(f&#39;protocol initializing from {self.__class__.__name__} with arguments {kwargs}&#39;)

        # set class properties
        self.device_type = device_type
        self.device_id = device_id
        self._is_connected = False
        self._shutdown_active = False

        self._message_id = 0
        self._msgid_lock = threading.Lock()
        self._send_queue = queue.Queue()
        self._stale_lock = threading.Lock()

        # make sure we have a basic set of parameters for the TCP connection
        self._params = {PLUGIN_ATTR_NET_HOST: &#39;&#39;,
                        PLUGIN_ATTR_NET_PORT: 9090,
                        PLUGIN_ATTR_CONN_AUTO_CONN: True,
                        PLUGIN_ATTR_CONN_RETRIES: 1,
                        PLUGIN_ATTR_CONN_CYCLE: 3,
                        PLUGIN_ATTR_CONN_TIMEOUT: 3,
                        PLUGIN_ATTR_MSG_REPEAT: 3,
                        PLUGIN_ATTR_MSG_TIMEOUT: 5,
                        PLUGIN_ATTR_CB_ON_DISCONNECT: None,
                        PLUGIN_ATTR_CB_ON_CONNECT: None,
                        PLUGIN_ATTR_CONNECTION: CONN_NET_TCP_CLI,
                        JSON_MOVE_KEYS: []}
        self._params.update(kwargs)

        # check if some of the arguments are usable
        self._set_connection_params()

        # self._message_archive[str message_id] = [time() sendtime, str method, str params or None, int repeat]
        self._message_archive = {}

        self._check_stale_cycle = float(self._params[PLUGIN_ATTR_MSG_TIMEOUT]) / 2
        self._next_stale_check = 0
        self._last_stale_check = 0

        self._data_received_callback = data_received_callback

        # initialize connection
        conn_params = self._params.copy()
        conn_params.update({PLUGIN_ATTR_CB_ON_CONNECT: self.on_connect, PLUGIN_ATTR_CB_ON_DISCONNECT: self.on_disconnect})
        self._connection = self._params[PLUGIN_ATTR_CONNECTION](device_type, device_id, self.on_data_received, **conn_params)

        # tell someone about our actual class
        self.logger.debug(f&#39;protocol initialized from {self.__class__.__name__}&#39;)

    def on_connect(self, by=None):
        self.logger.info(f&#39;onconnect called by {by}, send queue contains {self._send_queue.qsize()} commands&#39;)
        super().on_connect(by)

    def on_disconnect(self, by=None):
        super().on_disconnect(by)

        # did we power down? then clear queues
        if self._shutdown_active:
            self._send_queue = queue.Queue()
            self._stale_lock.acquire()
            self._message_archive = {}
            self._stale_lock.release()
            self._shutdown_active = False

    def on_data_received(self, connection, response):
        if isinstance(response, (bytes, bytearray)):
            response = str(response, &#39;utf-8&#39;).strip()

        # split multi-response data into list items
        try:
            datalist = response.replace(&#39;}{&#39;, &#39;}-#-{&#39;).split(&#39;-#-&#39;)
            datalist = list(OrderedDict((x, True) for x in datalist).keys())
        except Exception:
            datalist = [response]

        # process all response items
        for data in datalist:
            self.logger.debug(f&#39;Processing received data item #{datalist.index(data)} ({data})&#39;)

            try:
                jdata = json.loads(data)
            except Exception as err:
                self.logger.warning(f&#39;Could not json.load data item {data} with error {err}&#39;)
                continue

            command = None

            # check messageid for replies
            if &#39;id&#39; in jdata:
                response_id = jdata[&#39;id&#39;]

                # reply or error received, remove command
                if response_id in self._message_archive:
                    # possibly the command was resent and removed before processing the reply
                    # so let&#39;s &#39;try&#39; at least...
                    try:
                        command = self._message_archive[response_id][1]
                        del self._message_archive[response_id]
                    except KeyError:
                        command = &#39;(deleted)&#39; if &#39;_&#39; not in response_id else response_id[response_id.find(&#39;_&#39;) + 1:]
                else:
                    command = None

                # log possible errors
                if &#39;error&#39; in jdata:
                    self.logger.error(f&#39;received error {jdata} in response to command {command}&#39;)
                elif command:
                    self.logger.debug(f&#39;command {command} sent successfully&#39;)

            # process data
            if self._data_received_callback:
                self._data_received_callback(connection, jdata, command)

        # check _message_archive for old commands - check time reached?
        if self._next_stale_check &lt; time():

            # try to lock check routine, fail quickly if already locked = running
            if self._stale_lock.acquire(False):

                # we cannot deny access to self._message_archive as this would block sending
                # instead, copy it and check the copy
                stale_messages = self._message_archive.copy()
                remove_ids = []
                requeue_cmds = []

                # self._message_archive[message_id] = [time(), command, params, repeat]
                self.logger.debug(f&#39;Checking for unanswered commands, last check was {int(time()) - self._last_stale_check} seconds ago, {len(self._message_archive)} commands saved&#39;)
                # !! self.logger.debug(&#39;Stale commands: {}&#39;.format(stale_messages))
                for (message_id, (send_time, command, params, repeat)) in stale_messages.items():

                    if send_time + self._params[PLUGIN_ATTR_MSG_TIMEOUT] &lt; time():

                        # reply timeout reached, check repeat count
                        if repeat &lt;= self._params[PLUGIN_ATTR_MSG_REPEAT]:

                            # send again, increase counter
                            self.logger.info(f&#39;Repeating unanswered command {command} ({params}), try {repeat + 1}&#39;)
                            requeue_cmds.append([command, params, message_id, repeat + 1])
                        else:
                            self.logger.info(f&#39;Unanswered command {command} ({params}) repeated {repeat} times, giving up.&#39;)
                            remove_ids.append(message_id)

                for msgid in remove_ids:
                    # it is possible that while processing stale commands, a reply arrived
                    # and the command was removed. So just to be sure, &#39;try&#39; and delete...
                    self.logger.debug(f&#39;Removing stale msgid {msgid} from archive&#39;)
                    try:
                        del self._message_archive[msgid]
                    except KeyError:
                        pass

                # resend pending repeats - after original
                for (command, params, message_id, repeat) in requeue_cmds:
                    self._send_rpc_message(command, params, message_id, repeat)

                # set next stale check time
                self._last_stale_check = time()
                self._next_stale_check = self._last_stale_check + self._check_stale_cycle

                del stale_messages
                del requeue_cmds
                del remove_ids
                self._stale_lock.release()

            else:
                self.logger.debug(f&#39;Skipping stale check {time() - self._last_stale_check} seconds after last check&#39;)

    def _send(self, data_dict):
        &#34;&#34;&#34;
        wrapper to prepare json rpc message to send. extracts command, id, repeat and
        params (data) from data_dict and call send_rpc_message(command, params, id, repeat)
        &#34;&#34;&#34;
        command = data_dict.get(&#39;command&#39;, data_dict.get(&#39;method&#39;, data_dict.get(&#39;payload&#39;)))
        message_id = data_dict.get(&#39;message_id&#39;, None)
        repeat = data_dict.get(&#39;repeat&#39;, 0)

        self._send_rpc_message(command, data_dict, message_id, repeat)

        # we don&#39;t return a response (this goes via on_data_received)
        return None

    def _send_rpc_message(self, command, ddict=None, message_id=None, repeat=0):
        &#34;&#34;&#34;
        Send a JSON RPC message.
        The JSON string is extracted from the supplied command and the given parameters.

        :param command: the command to be triggered
        :param ddict: dictionary with command data, e.g. keys &#39;params&#39;, &#39;data&#39;, &#39;headers&#39;, &#39;request_method&#39;...
        :param message_id: the message ID to be used. If none, use the internal counter
        :param repeat: counter for how often the message has been repeated
        &#34;&#34;&#34;
        self.logger.debug(f&#39;preparing message to send command {command} with data {ddict}, try #{repeat}&#39;)

        if message_id is None:
            # safely acquire next message_id
            # !! self.logger.debug(&#39;Locking message id access ({})&#39;.format(self._message_id))
            self._msgid_lock.acquire()
            self._message_id += 1
            new_msgid = self._message_id
            self._msgid_lock.release()
            message_id = str(new_msgid) + &#39;_&#39; + command
            # !! self.logger.debug(&#39;Releasing message id access ({})&#39;.format(self._message_id))

        if not ddict:
            ddict = {}

        method = ddict.get(&#39;method&#39;, command)

        # create message packet
        new_data = {&#39;jsonrpc&#39;: &#39;2.0&#39;, &#39;id&#39;: message_id, &#39;method&#39;: method}
        
        if &#39;data&#39; in ddict and ddict[&#39;data&#39;]:

            # ddict already contains &#39;data&#39;, we either have an old &#34;ready&#34; packet or new data
            if &#39;jsonrpc&#39; not in ddict[&#39;data&#39;]:

                # we don&#39;t have a jsonrpc header, add new data to new header
                new_data[&#39;params&#39;] = ddict[&#39;data&#39;]
            else:
                # jsonrpc header present, keep packet as is
                new_data = ddict[&#39;data&#39;]
    
        # set packet data
        ddict[&#39;data&#39;] = new_data

        for key in self._params[JSON_MOVE_KEYS]:
            if key in ddict:
                if &#39;params&#39; not in ddict[&#39;data&#39;]:
                    ddict[&#39;data&#39;][&#39;params&#39;] = {}
                ddict[&#39;data&#39;][&#39;params&#39;][key] = ddict[key]
                del ddict[key]

        # convert data if not using HTTP connections
        if &#39;request_method&#39; not in ddict:

            try:
                # if &#39;payload&#39; in ddict:
                #     ddict[&#39;payload&#39;] += json.dumps(ddict[&#39;data&#39;])
                # else:
                ddict[&#39;payload&#39;] = json.dumps(ddict[&#39;data&#39;])                    
            except Exception as e:
                raise ValueError(f&#39;data {ddict[&#34;data&#34;]} not convertible to JSON, aborting. Error was: {e}&#39;)

        # push message in queue
        self._send_queue.put([message_id, command, ddict, repeat])

        # try to actually send all queued messages
        self.logger.debug(f&#39;processing queue - {self._send_queue.qsize()} elements&#39;)
        while not self._send_queue.empty():
            (message_id, command, ddict, repeat) = self._send_queue.get()

            self._message_archive[message_id] = [time(), command, ddict, repeat]

            self.logger.debug(f&#39;sending queued msg {message_id} - {command} (#{repeat})&#39;)
            response = self._connection.send(ddict)
            if response:
                self.on_data_received(&#39;request&#39;, response)


class MD_Protocol_Viessmann(MD_Protocol):
    &#34;&#34;&#34; Protocol support for Viessmann heating systems

    This class implements a Viessmann protocol layer. By default, this uses
    the P300 protocol. By supplying the &#39;viess_proto&#39; attribute, the older &#39;KW&#39;
    protocol can be selected.

    At the moment, this is oriented towards serial connections. By supplying
    your own connection type, you could try to use it over networked connections.
    Be advised that the necessary &#34;reply&#34; client and the methods needed are not
    implemented for network access as of this time...
    &#34;&#34;&#34;

    def __init__(self, device_type, device_id, data_received_callback, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if MD_standalone:
            self.logger = logging.getLogger(&#39;__main__&#39;)

        self.logger.debug(f&#39;protocol initializing from {self.__class__.__name__} with arguments {kwargs}&#39;)

        # set class properties
        self.device_type = device_type
        self.device_id = device_id
        self._is_connected = False
        self._error_count = 0
        self._lock = threading.Lock()
        self._is_initialized = False
        self._data_received_callback = data_received_callback

        self._controlsets = {
            &#39;P300&#39;: {
                &#39;baudrate&#39;: 4800,
                &#39;bytesize&#39;: 8,
                &#39;parity&#39;: &#39;E&#39;,
                &#39;stopbits&#39;: 2,
                &#39;timeout&#39;: 0.5,
                &#39;startbyte&#39;: 0x41,
                &#39;request&#39;: 0x00,
                &#39;response&#39;: 0x01,
                &#39;error&#39;: 0x03,
                &#39;read&#39;: 0x01,
                &#39;write&#39;: 0x02,
                &#39;functioncall&#39;: 0x7,
                &#39;acknowledge&#39;: 0x06,
                &#39;not_initiated&#39;: 0x05,
                &#39;init_error&#39;: 0x15,
                &#39;reset_command&#39;: 0x04,
                &#39;reset_command_response&#39;: 0x05,
                &#39;sync_command&#39;: 0x160000,
                &#39;sync_command_response&#39;: 0x06,
                &#39;command_bytes_read&#39;: 5,
                &#39;command_bytes_write&#39;: 5,
                # init:              send&#39;Reset_Command&#39; receive&#39;Reset_Command_Response&#39; send&#39;Sync_Command&#39;
                # request:           send(&#39;StartByte&#39; &#39;L채nge der Nutzdaten als Anzahl der Bytes zwischen diesem Byte und der Pr체fsumme&#39; &#39;Request&#39; &#39;Read&#39; &#39;addr&#39; &#39;checksum&#39;)
                # request_response:  receive(&#39;Acknowledge&#39; &#39;StartByte&#39; &#39;L채nge der Nutzdaten als Anzahl der Bytes zwischen diesem Byte und der Pr체fsumme&#39; &#39;Response&#39; &#39;Read&#39; &#39;addr&#39; &#39;Anzahl der Bytes des Wertes&#39; &#39;Wert&#39; &#39;checksum&#39;)
            },
            &#39;KW&#39;: {
                &#39;baudrate&#39;: 4800,
                &#39;bytesize&#39;: 8,          # &#39;EIGHTBITS&#39;
                &#39;parity&#39;: &#39;E&#39;,          # &#39;PARITY_EVEN&#39;,
                &#39;stopbits&#39;: 2,          # &#39;STOPBITS_TWO&#39;,
                &#39;timeout&#39;: 1,
                &#39;startbyte&#39;: 0x01,
                &#39;read&#39;: 0xF7,
                &#39;write&#39;: 0xF4,
                &#39;acknowledge&#39;: 0x01,
                &#39;reset_command&#39;: 0x04,
                &#39;not_initiated&#39;: 0x05,
                &#39;write_ack&#39;: 0x00,
            },
        }

        # get protocol or default to P300
        self._viess_proto = kwargs.get(&#39;viess_proto&#39;, &#39;P300&#39;)
        if self._viess_proto not in self._controlsets:
            self._viess_proto = &#39;P300&#39;
        # select controlset for viess_proto
        self._controlset = self._controlsets[self._viess_proto]

        # make sure we have a basic set of parameters for the TCP connection
        self._params = {PLUGIN_ATTR_SERIAL_PORT: &#39;&#39;,
                        PLUGIN_ATTR_SERIAL_BAUD: self._controlset[PLUGIN_ATTR_SERIAL_BAUD],
                        PLUGIN_ATTR_SERIAL_BSIZE: self._controlset[PLUGIN_ATTR_SERIAL_BSIZE],
                        PLUGIN_ATTR_SERIAL_PARITY: self._controlset[PLUGIN_ATTR_SERIAL_PARITY],
                        PLUGIN_ATTR_SERIAL_STOP: self._controlset[PLUGIN_ATTR_SERIAL_STOP],
                        PLUGIN_ATTR_CONN_TIMEOUT: self._controlset[PLUGIN_ATTR_CONN_TIMEOUT],
                        PLUGIN_ATTR_CONN_AUTO_CONN: True,
                        PLUGIN_ATTR_CONN_BINARY: True,
                        PLUGIN_ATTR_CONN_RETRIES: 0,
                        PLUGIN_ATTR_CONN_CYCLE: 3,
                        PLUGIN_ATTR_CB_ON_CONNECT: None,
                        PLUGIN_ATTR_CB_ON_DISCONNECT: None,
                        PLUGIN_ATTR_CONNECTION: CONN_SER_DIR}
        self._params.update(kwargs)

        # check if some of the arguments are usable
        self._set_connection_params()

        # initialize connection
        conn_params = self._params.copy()
        # don&#39;t supply callback, we do only reply-based work
        conn_params.update({PLUGIN_ATTR_CB_ON_CONNECT: None, PLUGIN_ATTR_CB_ON_DISCONNECT: None})
        self._connection = self._params[PLUGIN_ATTR_CONNECTION](device_type, device_id, None, **conn_params)

        # set &#34;method pointers&#34;
        self._send_bytes = self._connection._send_bytes
        self._read_bytes = self._connection._read_bytes

        # tell someone about our actual class
        self.logger.debug(f&#39;protocol initialized from {self.__class__.__name__}&#39;)

    def _close(self):
        self._is_initialized = False
        super()._close()

    def _send_init_on_send(self):
        &#34;&#34;&#34;
        setup the communication protocol prior to sending

        :return: Returns True, if communication was established successfully, False otherwise
        :rtype: bool
        &#34;&#34;&#34;
        if self._viess_proto == &#39;P300&#39; and not self._is_initialized:

            # init procedure is
            # interface: 0x04 (reset)
            #                           device: 0x05 (repeated)
            # interface: 0x160000 (sync)
            #                           device: 0x06 (sync ok)
            # interface: resume communication, periodically send 0x160000 as keepalive if necessary

            RESET = self._int2bytes(self._controlset[&#39;reset_command&#39;], 1)
            NOTINIT = self._int2bytes(self._controlset[&#34;not_initiated&#34;], 1)
            ACK = self._int2bytes(self._controlset[&#39;acknowledge&#39;], 1)
            SYNC = self._int2bytes(self._controlset[&#39;sync_command&#39;], 3)
            ERR = self._int2bytes(self._controlset[&#39;init_error&#39;], 1)

            self.logger.debug(&#39;init communication....&#39;)
            syncsent = False

            self.logger.debug(f&#39;send_bytes: send reset command {RESET}&#39;)
            self._send_bytes(RESET)

            readbyte = self._read_bytes(1)
            self.logger.debug(f&#39;read_bytes: read {readbyte}&#39;)

            for i in range(10):
                if syncsent and readbyte == ACK:
                    self.logger.debug(&#39;device acknowledged initialization&#39;)
                    self._is_initialized = True
                    break
                elif readbyte == NOTINIT:
                    self.logger.debug(f&#39;send_bytes: send sync command {SYNC}&#39;)
                    self._send_bytes(SYNC)
                    syncsent = True
                elif readbyte == ERR:
                    self.logger.error(f&#39;interface reported an error, loop increment {i}&#39;)
                    self.logger.debug(f&#39;send_bytes: send reset command {RESET}&#39;)
                    self._send_bytes(RESET)
                    syncsent = False
                else:   # elif readbyte != b&#39;&#39;:
                    self.logger.debug(f&#39;send_bytes: send reset command {RESET}&#39;)
                    self._send_bytes(RESET)
                    syncsent = False
                readbyte = self._read_bytes(1)
                self.logger.debug(f&#39;read_bytes: read {readbyte}&#39;)

            self.logger.debug(f&#39;communication initialized: {self._is_initialized}&#39;)
            return self._is_initialized

        elif self._viess_proto == &#39;KW&#39;:

            retries = 5
            RESET = self._int2bytes(self._controlset[&#39;reset_command&#39;], 1)
            NOINIT = self._int2bytes(self._controlset[&#39;not_initiated&#39;], 1, signed=False)

            # try to reset communication, especially if previous P300 comms is still open
            self._send_bytes(RESET)

            attempt = 0
            while attempt &lt; retries:
                self.logger.debug(f&#39;starting sync loop - attempt {attempt + 1}/{retries}&#39;)

                self._connection.reset_input_buffer()
                chunk = self._read_bytes(1)
                # enable for &#39;raw&#39; debugging
                # self.logger.debug(f&#39;sync loop - got {self._bytes2hexstring(chunk)}&#39;)
                if chunk == NOINIT:
                    self.logger.debug(&#39;got sync, commencing command send&#39;)
                    self._is_initialized = True
                    return True
                sleep(.8)
                attempt = attempt + 1
            self.logger.error(f&#39;sync not acquired after {attempt} attempts&#39;)
            self._close()
            return False

        return True

    def _send(self, data_dict):
        &#34;&#34;&#34;
        send data. data_dict needs to contain the following information:

        data_dict[&#39;payload&#39;]: address from/to which to read/write (hex, str)
        data_dict[&#39;data&#39;][&#39;len&#39;]: length of command to send
        data_dict[&#39;data&#39;][&#39;value&#39;]: value bytes to write, None if reading

        :param data_dict: send data
        :param read_response: KW only: read response value (True) or only return status byte
        :type data_dict: dict
        :type read_response: bool
        :return: Response packet (bytearray) if no error occured, None otherwise
        &#34;&#34;&#34;
        (packet, responselen) = self._build_payload(data_dict)

        # send payload
        self._lock.acquire()
        try:
            self._send_bytes(packet)
            self.logger.debug(f&#39;successfully sent packet {self._bytes2hexstring(packet)}&#39;)

            # receive response
            response_packet = bytearray()
            self.logger.debug(f&#39;trying to receive {responselen} bytes of the response&#39;)
            chunk = self._read_bytes(responselen)
            if self._viess_proto == &#39;P300&#39;:
                self.logger.debug(f&#39;received {len(chunk)} bytes chunk of response as hexstring {self._bytes2hexstring(chunk)} and as bytes {chunk}&#39;)
                if len(chunk) != 0:
                    if chunk[:1] == self._int2bytes(self._controlset[&#39;error&#39;], 1):
                        self.logger.error(f&#39;interface returned error, response was {chunk}&#39;)
                    elif len(chunk) == 1 and chunk[:1] == self._int2bytes(self._controlset[&#39;not_initiated&#39;], 1):
                        self.logger.error(&#39;received invalid chunk, connection not initialized, forcing re-initialize...&#39;)
                        self._initialized = False
                    elif chunk[:1] != self._int2bytes(self._controlset[&#39;acknowledge&#39;], 1):
                        self.logger.error(f&#39;received invalid chunk, not starting with ACK, response was {chunk}&#39;)
                        self._error_count += 1
                        if self._error_count &gt;= 5:
                            self.logger.warning(&#39;encountered 5 invalid chunks in sequence, maybe communication was lost, forcing re-initialize&#39;)
                            self._initialized = False
                    else:
                        response_packet.extend(chunk)
                        self._error_count = 0
                        return self._parse_response(response_packet)
                else:
                    self.logger.error(f&#39;received 0 bytes chunk - ignoring response_packet, chunk was {chunk}&#39;)
            elif self._protocol == &#39;KW&#39;:
                self.logger.debug(f&#39;received {len(chunk)} bytes chunk of response as hexstring {self._bytes2hexstring(chunk)} and as bytes {chunk}&#39;)
                if len(chunk) != 0:
                    response_packet.extend(chunk)
                    return self._parse_response(response_packet, data_dict[&#39;data&#39;][&#39;value&#39;] is None)
                else:
                    self.logger.error(&#39;received 0 bytes chunk - this probably is a communication error, possibly a wrong datapoint address?&#39;)
        except IOError as e:
            self.logger.error(f&#39;send_command_packet failed with IO error, trying to reconnect. Error was: {e}&#39;)
            self._close()
        except Exception as e:
            self.logger.error(f&#39;send_command_packet failed with error: {e}&#39;)
        finally:
            try:
                self._lock.release()
            except RuntimeError:
                pass

        # if we didn&#39;t return with data earlier, we hit an error. Act accordingly
        return None

    def _parse_response(self, response, read_response=True):
        &#34;&#34;&#34;
        Process device response data, try to parse type and value

        :param response: Data received from device
        :type response: bytearray
        :param read_response: True if command was read command and value is expected, False if only status byte is expected (only needed for KW protocol)
        :type read_response: bool
        :return: tuple of (parsed response value, commandcode) or None if error
        &#34;&#34;&#34;
        if self._viess_proto == &#39;P300&#39;:

            # A read_response telegram looks like this: ACK (1 byte), startbyte (1 byte), data length in bytes (1 byte), request/response (1 byte), read/write (1 byte), addr (2 byte), amount of valuebytes (1 byte), value (bytes as per last byte), checksum (1 byte)
            # A write_response telegram looks like this: ACK (1 byte), startbyte (1 byte), data length in bytes (1 byte), request/response (1 byte), read/write (1 byte), addr (2 byte), amount of bytes written (1 byte), checksum (1 byte)

            # Validate checksum
            checksum = self._calc_checksum(response[1:len(response) - 1])  # first, cut first byte (ACK) and last byte (checksum) and then calculate checksum
            received_checksum = response[len(response) - 1]
            if received_checksum != checksum:
                self.logger.error(f&#39;calculated checksum {checksum} does not match received checksum of {received_checksum}! Ignoring reponse&#39;)
                return None

            # Extract command/address, valuebytes and valuebytecount out of response
            responsetypecode = response[3]  # 0x00 = query, 0x01 = reply, 0x03 = error
            responsedatacode = response[4]  # 0x01 = ReadData, 0x02 = WriteData, 0x07 = Function Call
            valuebytecount = response[7]

            # Extract databytes out of response
            rawdatabytes = bytearray()
            rawdatabytes.extend(response[8:8 + (valuebytecount)])
        elif self._protocol == &#39;KW&#39;:

            # imitate P300 response code data for easier combined handling afterwards
            # a read_response telegram consists only of the value bytes
            # a write_response telegram is 0x00 for OK, 0xXX for error
            responsetypecode = 1
            valuebytecount = len(response)
            rawdatabytes = response

            if read_response:
                # value response to read request, error detection by empty = no response
                responsedatacode = 1
                if len(rawdatabytes) == 0:
                    # error, no answer means wrong address (?)
                    responsetypecode = 3
            else:
                # status response to write request
                responsedatacode = 2
                if (len(rawdatabytes) == 1 and rawdatabytes[0] != 0) or len(rawdatabytes) == 0:
                    # error if status reply is not 0x00
                    responsetypecode = 3

        self.logger.debug(f&#39;Response decoded to: responsedatacode: {responsedatacode}, valuebytecount: {valuebytecount}, responsetypecode: {responsetypecode}&#39;)

        if responsetypecode == 3:
            raise ValueError(f&#39;error on reading reply {rawdatabytes}&#39;)

        if responsedatacode == 2:
            self.logger.debug(&#39;write request successful&#39;)
            return None

        self.logger.debug(f&#39;read request successful, read bytes {rawdatabytes}&#39;)
        return rawdatabytes

    def _build_payload(self, data_dict):
        &#34;&#34;&#34;
        create payload from data_dict. Necessary data:

        data_dict[&#39;payload&#39;]: address from/to which to read/write (hex, str)
        data_dict[&#39;data&#39;][&#39;len&#39;]: length of command to send
        data_dict[&#39;data&#39;][&#39;value&#39;]: value bytes to write, None if reading
        data_dict[&#39;data&#39;][&#39;kwseq&#39;]: packet is follow-up packet in KW

        :param data_dict: data to convert
        :type data_dict: dict
        :return: (packet, responselen)
        :rtype: tuple
        &#34;&#34;&#34;
        try:
            addr = data_dict[&#39;payload&#39;].lower()
            cmdlen = data_dict[&#39;data&#39;][&#39;len&#39;]
            valuebytes = data_dict[&#39;data&#39;][&#39;value&#39;]
            KWFollowUp = data_dict[&#39;data&#39;].get(&#39;kwseq&#39;, False)
        except Exception as e:
            raise ValueError(f&#39;data_dict {data_dict} not usable, data not sent. Error was: {e}&#39;)

        write = valuebytes is not None

        # build payload
        if write:
            payloadlength = int(self._controlset.get(&#39;command_bytes_write&#39;, 0)) + int(valuebytes)
            self.logger.debug(f&#39;Payload length is: {payloadlength} bytes&#39;)

        packet = bytearray()
        if not KWFollowUp:
            packet.extend(self._int2bytes(self._controlset[&#39;startbyte&#39;], 1))
        if self._viess_proto == &#39;P300&#39;:
            if write:
                packet.extend(self._int2bytes(payloadlength, 1))
            else:
                packet.extend(self._int2bytes(self._controlset[&#39;command_bytes_read&#39;], 1))
            packet.extend(self._int2bytes(self._controlset[&#39;request&#39;], 1))

        if write:
            packet.extend(self._int2bytes(self._controlset[&#39;write&#39;], 1))
        else:
            packet.extend(self._int2bytes(self._controlset[&#39;read&#39;], 1))
        packet.extend(bytes.fromhex(addr))
        packet.extend(self._int2bytes(cmdlen, 1))
        if write:
            packet.extend(valuebytes)
        if self._viess_proto == &#39;P300&#39;:
            packet.extend(self._int2bytes(self._calc_checksum(packet), 1))

        if self._viess_proto == &#39;P300&#39;:
            responselen = int(self._controlset[&#39;command_bytes_read&#39;]) + 4 + (0 if write else int(cmdlen))
        else:
            responselen = 1 if write else int(cmdlen)

        if write:
            self.logger.debug(f&#39;created payload to be sent as hexstring: {self._bytes2hexstring(packet)} and as bytes: {packet} with value {self._bytes2hexstring(valuebytes)})&#39;)
        else:
            self.logger.debug(f&#39;created payload to be sent as hexstring: {self._bytes2hexstring(packet)} and as bytes: {packet}&#39;)

        return (packet, responselen)

    @staticmethod
    def _calc_checksum(packet):
        &#34;&#34;&#34;
        Calculate checksum for P300 protocol packets

        :parameter packet: Data packet for which to calculate checksum
        :type packet: bytearray
        :return: Calculated checksum
        :rtype: int
        &#34;&#34;&#34;
        checksum = 0
        if len(packet) &gt; 0:
            if packet[:1] == b&#39;\x41&#39;:
                packet = packet[1:]
                checksum = sum(packet)
                checksum = checksum - int(checksum / 256) * 256
        return checksum

    @staticmethod
    def _int2bytes(value, length, signed=False):
        &#34;&#34;&#34;
        Convert value to bytearray with respect to defined length and sign format.
        Value exceeding limit set by length and sign will be truncated

        :parameter value: Value to convert
        :type value: int
        :parameter length: number of bytes to create
        :type length: int
        :parameter signed: True if result should be a signed int, False for unsigned
        :type signed: bool
        :return: Converted value
        :rtype: bytearray
        &#34;&#34;&#34;
        value = value % (2 ** (length * 8))
        return value.to_bytes(length, byteorder=&#39;big&#39;, signed=signed)

    @staticmethod
    def _bytes2int(rawbytes, signed):
        &#34;&#34;&#34;
        Convert bytearray to value with respect to sign format

        :parameter rawbytes: Bytes to convert
        :type value: bytearray
        :parameter signed: True if result should be a signed int, False for unsigned
        :type signed: bool
        :return: Converted value
        :rtype: int
        &#34;&#34;&#34;
        return int.from_bytes(rawbytes, byteorder=&#39;little&#39;, signed=signed)

    @staticmethod
    def _bytes2hexstring(bytesvalue):
        &#34;&#34;&#34;
        Create hex-formatted string from bytearray
        :param bytesvalue: Bytes to convert
        :type bytesvalue: bytearray
        :return: Converted hex string
        :rtype: str
        &#34;&#34;&#34;
        return &#39;&#39;.join(f&#39;{c:02x}&#39; for c in bytesvalue)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multidevice.MD_Protocol.MD_Protocol"><code class="flex name class">
<span>class <span class="ident">MD_Protocol</span></span>
<span>(</span><span>device_type, device_id, data_received_callback, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MD_Protocol class to provide protocol support for MD_Device</p>
<p>This class implements a basic protocol layer to act as a standin between
the MD_Device-class and the MD_Connection-class. Its purpose is to enable
establishing a control layer, so the connection only has to care for the
'physical' connection and the device only needs to operate on commmand basis.</p>
<p>This implementation can also be seen as a 'NULL' protocol, it only passes
along everything.</p>
<p>By overwriting this class, different protocols can be implemented independent
of the device and the connection classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Protocol(MD_Connection):
    &#34;&#34;&#34; MD_Protocol class to provide protocol support for MD_Device

    This class implements a basic protocol layer to act as a standin between
    the MD_Device-class and the MD_Connection-class. Its purpose is to enable
    establishing a control layer, so the connection only has to care for the
    &#39;physical&#39; connection and the device only needs to operate on commmand basis.

    This implementation can also be seen as a &#39;NULL&#39; protocol, it only passes
    along everything.

    By overwriting this class, different protocols can be implemented independent
    of the device and the connection classes.
    &#34;&#34;&#34;

    def __init__(self, device_type, device_id, data_received_callback, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if MD_standalone:
            self.logger = logging.getLogger(&#39;__main__&#39;)

        self.logger.debug(f&#39;protocol initializing from {self.__class__.__name__} with arguments {kwargs}&#39;)

        # set class properties
        self.device_type = device_type
        self.device_id = device_id
        self._is_connected = False
        self._data_received_callback = data_received_callback

        # make sure we have a basic set of parameters
        self._params = {PLUGIN_ATTR_CB_ON_DISCONNECT: None,
                        PLUGIN_ATTR_CB_ON_CONNECT: None,
                        PLUGIN_ATTR_MSG_TIMEOUT: 3,
                        PLUGIN_ATTR_MSG_REPEAT: 3,
                        PLUGIN_ATTR_CONNECTION: MD_Connection}
        self._params.update(kwargs)

        # check if some of the arguments are usable
        self._set_connection_params()

        # initialize connection
        conn_params = self._params.copy()
        conn_params.update({PLUGIN_ATTR_CB_ON_CONNECT: self.on_connect, PLUGIN_ATTR_CB_ON_DISCONNECT: self.on_disconnect})
        self._connection = self._params[PLUGIN_ATTR_CONNECTION](device_type, device_id, self.on_data_received, **conn_params)

        # tell someone about our actual class
        self.logger.debug(f&#39;protocol initialized from {self.__class__.__name__}&#39;)

    def _open(self):
        self.logger.debug(f&#39;{self.__class__.__name__} _open called, opening protocol with params {self._params}&#39;)
        if not self._connection.connected():
            self._connection.open()

        self._is_connected = self._connection.connected()
        return self._is_connected

    def _close(self):
        self.logger.debug(f&#39;{self.__class__.__name__} _close called, closing protocol&#39;)
        self._connection.close()
        self._is_connected = False

    def _send(self, data_dict):
        self.logger.debug(f&#39;{self.__class__.__name__} _send called with {data_dict}&#39;)
        return self._connection.send(data_dict)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Connection.MD_Connection" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection">MD_Connection</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Protocol.MD_Protocol_Jsonrpc" href="#multidevice.MD_Protocol.MD_Protocol_Jsonrpc">MD_Protocol_Jsonrpc</a></li>
<li><a title="multidevice.MD_Protocol.MD_Protocol_Viessmann" href="#multidevice.MD_Protocol.MD_Protocol_Viessmann">MD_Protocol_Viessmann</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Connection.MD_Connection" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection">MD_Connection</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Connection.MD_Connection.close" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.close">close</a></code></li>
<li><code><a title="multidevice.MD_Connection.MD_Connection.connected" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.connected">connected</a></code></li>
<li><code><a title="multidevice.MD_Connection.MD_Connection.on_connect" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_connect">on_connect</a></code></li>
<li><code><a title="multidevice.MD_Connection.MD_Connection.on_data_received" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_data_received">on_data_received</a></code></li>
<li><code><a title="multidevice.MD_Connection.MD_Connection.on_disconnect" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_disconnect">on_disconnect</a></code></li>
<li><code><a title="multidevice.MD_Connection.MD_Connection.open" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.open">open</a></code></li>
<li><code><a title="multidevice.MD_Connection.MD_Connection.send" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.send">send</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Protocol.MD_Protocol_Jsonrpc"><code class="flex name class">
<span>class <span class="ident">MD_Protocol_Jsonrpc</span></span>
<span>(</span><span>device_type, device_id, data_received_callback, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol support for JSON-RPC 2.0</p>
<p>This class implements a protocol to send JSONRPC 2.0
compatible messages
As JSONRPC includes message-ids, replies can be associated to their respective
queries and reply tracing and command repeat functions are implemented.</p>
<p>Data received is dispatched via callback, thus the send()-method does not
return any response data.</p>
<p>Callback syntax is:
def connected_callback(by=None)
def disconnected_callback(by=None)
def data_received_callback(by, message, command=None)
If callbacks are class members, they need the additional first parameter 'self'</p>
<p>:param device_type: device type as used in commands.py name
:param device_id: device id for use in item configuration and logs
:type device_type: str
:type device_id: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Protocol_Jsonrpc(MD_Protocol):
    &#34;&#34;&#34; Protocol support for JSON-RPC 2.0

    This class implements a protocol to send JSONRPC 2.0  compatible messages
    As JSONRPC includes message-ids, replies can be associated to their respective
    queries and reply tracing and command repeat functions are implemented.

    Data received is dispatched via callback, thus the send()-method does not
    return any response data.

    Callback syntax is:
        def connected_callback(by=None)
        def disconnected_callback(by=None)
        def data_received_callback(by, message, command=None)
    If callbacks are class members, they need the additional first parameter &#39;self&#39;

    :param device_type: device type as used in commands.py name
    :param device_id: device id for use in item configuration and logs
    :type device_type: str
    :type device_id: str
    &#34;&#34;&#34;
    def __init__(self, device_type, device_id, data_received_callback, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if MD_standalone:
            self.logger = logging.getLogger(&#39;__main__&#39;)

        self.logger.debug(f&#39;protocol initializing from {self.__class__.__name__} with arguments {kwargs}&#39;)

        # set class properties
        self.device_type = device_type
        self.device_id = device_id
        self._is_connected = False
        self._shutdown_active = False

        self._message_id = 0
        self._msgid_lock = threading.Lock()
        self._send_queue = queue.Queue()
        self._stale_lock = threading.Lock()

        # make sure we have a basic set of parameters for the TCP connection
        self._params = {PLUGIN_ATTR_NET_HOST: &#39;&#39;,
                        PLUGIN_ATTR_NET_PORT: 9090,
                        PLUGIN_ATTR_CONN_AUTO_CONN: True,
                        PLUGIN_ATTR_CONN_RETRIES: 1,
                        PLUGIN_ATTR_CONN_CYCLE: 3,
                        PLUGIN_ATTR_CONN_TIMEOUT: 3,
                        PLUGIN_ATTR_MSG_REPEAT: 3,
                        PLUGIN_ATTR_MSG_TIMEOUT: 5,
                        PLUGIN_ATTR_CB_ON_DISCONNECT: None,
                        PLUGIN_ATTR_CB_ON_CONNECT: None,
                        PLUGIN_ATTR_CONNECTION: CONN_NET_TCP_CLI,
                        JSON_MOVE_KEYS: []}
        self._params.update(kwargs)

        # check if some of the arguments are usable
        self._set_connection_params()

        # self._message_archive[str message_id] = [time() sendtime, str method, str params or None, int repeat]
        self._message_archive = {}

        self._check_stale_cycle = float(self._params[PLUGIN_ATTR_MSG_TIMEOUT]) / 2
        self._next_stale_check = 0
        self._last_stale_check = 0

        self._data_received_callback = data_received_callback

        # initialize connection
        conn_params = self._params.copy()
        conn_params.update({PLUGIN_ATTR_CB_ON_CONNECT: self.on_connect, PLUGIN_ATTR_CB_ON_DISCONNECT: self.on_disconnect})
        self._connection = self._params[PLUGIN_ATTR_CONNECTION](device_type, device_id, self.on_data_received, **conn_params)

        # tell someone about our actual class
        self.logger.debug(f&#39;protocol initialized from {self.__class__.__name__}&#39;)

    def on_connect(self, by=None):
        self.logger.info(f&#39;onconnect called by {by}, send queue contains {self._send_queue.qsize()} commands&#39;)
        super().on_connect(by)

    def on_disconnect(self, by=None):
        super().on_disconnect(by)

        # did we power down? then clear queues
        if self._shutdown_active:
            self._send_queue = queue.Queue()
            self._stale_lock.acquire()
            self._message_archive = {}
            self._stale_lock.release()
            self._shutdown_active = False

    def on_data_received(self, connection, response):
        if isinstance(response, (bytes, bytearray)):
            response = str(response, &#39;utf-8&#39;).strip()

        # split multi-response data into list items
        try:
            datalist = response.replace(&#39;}{&#39;, &#39;}-#-{&#39;).split(&#39;-#-&#39;)
            datalist = list(OrderedDict((x, True) for x in datalist).keys())
        except Exception:
            datalist = [response]

        # process all response items
        for data in datalist:
            self.logger.debug(f&#39;Processing received data item #{datalist.index(data)} ({data})&#39;)

            try:
                jdata = json.loads(data)
            except Exception as err:
                self.logger.warning(f&#39;Could not json.load data item {data} with error {err}&#39;)
                continue

            command = None

            # check messageid for replies
            if &#39;id&#39; in jdata:
                response_id = jdata[&#39;id&#39;]

                # reply or error received, remove command
                if response_id in self._message_archive:
                    # possibly the command was resent and removed before processing the reply
                    # so let&#39;s &#39;try&#39; at least...
                    try:
                        command = self._message_archive[response_id][1]
                        del self._message_archive[response_id]
                    except KeyError:
                        command = &#39;(deleted)&#39; if &#39;_&#39; not in response_id else response_id[response_id.find(&#39;_&#39;) + 1:]
                else:
                    command = None

                # log possible errors
                if &#39;error&#39; in jdata:
                    self.logger.error(f&#39;received error {jdata} in response to command {command}&#39;)
                elif command:
                    self.logger.debug(f&#39;command {command} sent successfully&#39;)

            # process data
            if self._data_received_callback:
                self._data_received_callback(connection, jdata, command)

        # check _message_archive for old commands - check time reached?
        if self._next_stale_check &lt; time():

            # try to lock check routine, fail quickly if already locked = running
            if self._stale_lock.acquire(False):

                # we cannot deny access to self._message_archive as this would block sending
                # instead, copy it and check the copy
                stale_messages = self._message_archive.copy()
                remove_ids = []
                requeue_cmds = []

                # self._message_archive[message_id] = [time(), command, params, repeat]
                self.logger.debug(f&#39;Checking for unanswered commands, last check was {int(time()) - self._last_stale_check} seconds ago, {len(self._message_archive)} commands saved&#39;)
                # !! self.logger.debug(&#39;Stale commands: {}&#39;.format(stale_messages))
                for (message_id, (send_time, command, params, repeat)) in stale_messages.items():

                    if send_time + self._params[PLUGIN_ATTR_MSG_TIMEOUT] &lt; time():

                        # reply timeout reached, check repeat count
                        if repeat &lt;= self._params[PLUGIN_ATTR_MSG_REPEAT]:

                            # send again, increase counter
                            self.logger.info(f&#39;Repeating unanswered command {command} ({params}), try {repeat + 1}&#39;)
                            requeue_cmds.append([command, params, message_id, repeat + 1])
                        else:
                            self.logger.info(f&#39;Unanswered command {command} ({params}) repeated {repeat} times, giving up.&#39;)
                            remove_ids.append(message_id)

                for msgid in remove_ids:
                    # it is possible that while processing stale commands, a reply arrived
                    # and the command was removed. So just to be sure, &#39;try&#39; and delete...
                    self.logger.debug(f&#39;Removing stale msgid {msgid} from archive&#39;)
                    try:
                        del self._message_archive[msgid]
                    except KeyError:
                        pass

                # resend pending repeats - after original
                for (command, params, message_id, repeat) in requeue_cmds:
                    self._send_rpc_message(command, params, message_id, repeat)

                # set next stale check time
                self._last_stale_check = time()
                self._next_stale_check = self._last_stale_check + self._check_stale_cycle

                del stale_messages
                del requeue_cmds
                del remove_ids
                self._stale_lock.release()

            else:
                self.logger.debug(f&#39;Skipping stale check {time() - self._last_stale_check} seconds after last check&#39;)

    def _send(self, data_dict):
        &#34;&#34;&#34;
        wrapper to prepare json rpc message to send. extracts command, id, repeat and
        params (data) from data_dict and call send_rpc_message(command, params, id, repeat)
        &#34;&#34;&#34;
        command = data_dict.get(&#39;command&#39;, data_dict.get(&#39;method&#39;, data_dict.get(&#39;payload&#39;)))
        message_id = data_dict.get(&#39;message_id&#39;, None)
        repeat = data_dict.get(&#39;repeat&#39;, 0)

        self._send_rpc_message(command, data_dict, message_id, repeat)

        # we don&#39;t return a response (this goes via on_data_received)
        return None

    def _send_rpc_message(self, command, ddict=None, message_id=None, repeat=0):
        &#34;&#34;&#34;
        Send a JSON RPC message.
        The JSON string is extracted from the supplied command and the given parameters.

        :param command: the command to be triggered
        :param ddict: dictionary with command data, e.g. keys &#39;params&#39;, &#39;data&#39;, &#39;headers&#39;, &#39;request_method&#39;...
        :param message_id: the message ID to be used. If none, use the internal counter
        :param repeat: counter for how often the message has been repeated
        &#34;&#34;&#34;
        self.logger.debug(f&#39;preparing message to send command {command} with data {ddict}, try #{repeat}&#39;)

        if message_id is None:
            # safely acquire next message_id
            # !! self.logger.debug(&#39;Locking message id access ({})&#39;.format(self._message_id))
            self._msgid_lock.acquire()
            self._message_id += 1
            new_msgid = self._message_id
            self._msgid_lock.release()
            message_id = str(new_msgid) + &#39;_&#39; + command
            # !! self.logger.debug(&#39;Releasing message id access ({})&#39;.format(self._message_id))

        if not ddict:
            ddict = {}

        method = ddict.get(&#39;method&#39;, command)

        # create message packet
        new_data = {&#39;jsonrpc&#39;: &#39;2.0&#39;, &#39;id&#39;: message_id, &#39;method&#39;: method}
        
        if &#39;data&#39; in ddict and ddict[&#39;data&#39;]:

            # ddict already contains &#39;data&#39;, we either have an old &#34;ready&#34; packet or new data
            if &#39;jsonrpc&#39; not in ddict[&#39;data&#39;]:

                # we don&#39;t have a jsonrpc header, add new data to new header
                new_data[&#39;params&#39;] = ddict[&#39;data&#39;]
            else:
                # jsonrpc header present, keep packet as is
                new_data = ddict[&#39;data&#39;]
    
        # set packet data
        ddict[&#39;data&#39;] = new_data

        for key in self._params[JSON_MOVE_KEYS]:
            if key in ddict:
                if &#39;params&#39; not in ddict[&#39;data&#39;]:
                    ddict[&#39;data&#39;][&#39;params&#39;] = {}
                ddict[&#39;data&#39;][&#39;params&#39;][key] = ddict[key]
                del ddict[key]

        # convert data if not using HTTP connections
        if &#39;request_method&#39; not in ddict:

            try:
                # if &#39;payload&#39; in ddict:
                #     ddict[&#39;payload&#39;] += json.dumps(ddict[&#39;data&#39;])
                # else:
                ddict[&#39;payload&#39;] = json.dumps(ddict[&#39;data&#39;])                    
            except Exception as e:
                raise ValueError(f&#39;data {ddict[&#34;data&#34;]} not convertible to JSON, aborting. Error was: {e}&#39;)

        # push message in queue
        self._send_queue.put([message_id, command, ddict, repeat])

        # try to actually send all queued messages
        self.logger.debug(f&#39;processing queue - {self._send_queue.qsize()} elements&#39;)
        while not self._send_queue.empty():
            (message_id, command, ddict, repeat) = self._send_queue.get()

            self._message_archive[message_id] = [time(), command, ddict, repeat]

            self.logger.debug(f&#39;sending queued msg {message_id} - {command} (#{repeat})&#39;)
            response = self._connection.send(ddict)
            if response:
                self.on_data_received(&#39;request&#39;, response)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Protocol.MD_Protocol" href="#multidevice.MD_Protocol.MD_Protocol">MD_Protocol</a></li>
<li><a title="multidevice.MD_Connection.MD_Connection" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection">MD_Connection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Protocol.MD_Protocol" href="#multidevice.MD_Protocol.MD_Protocol">MD_Protocol</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.close" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.close">close</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.connected" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.connected">connected</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.on_connect" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_connect">on_connect</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.on_data_received" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_data_received">on_data_received</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.on_disconnect" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_disconnect">on_disconnect</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.open" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.open">open</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.send" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.send">send</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Protocol.MD_Protocol_Viessmann"><code class="flex name class">
<span>class <span class="ident">MD_Protocol_Viessmann</span></span>
<span>(</span><span>device_type, device_id, data_received_callback, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol support for Viessmann heating systems</p>
<p>This class implements a Viessmann protocol layer. By default, this uses
the P300 protocol. By supplying the 'viess_proto' attribute, the older 'KW'
protocol can be selected.</p>
<p>At the moment, this is oriented towards serial connections. By supplying
your own connection type, you could try to use it over networked connections.
Be advised that the necessary "reply" client and the methods needed are not
implemented for network access as of this time&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Protocol_Viessmann(MD_Protocol):
    &#34;&#34;&#34; Protocol support for Viessmann heating systems

    This class implements a Viessmann protocol layer. By default, this uses
    the P300 protocol. By supplying the &#39;viess_proto&#39; attribute, the older &#39;KW&#39;
    protocol can be selected.

    At the moment, this is oriented towards serial connections. By supplying
    your own connection type, you could try to use it over networked connections.
    Be advised that the necessary &#34;reply&#34; client and the methods needed are not
    implemented for network access as of this time...
    &#34;&#34;&#34;

    def __init__(self, device_type, device_id, data_received_callback, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if MD_standalone:
            self.logger = logging.getLogger(&#39;__main__&#39;)

        self.logger.debug(f&#39;protocol initializing from {self.__class__.__name__} with arguments {kwargs}&#39;)

        # set class properties
        self.device_type = device_type
        self.device_id = device_id
        self._is_connected = False
        self._error_count = 0
        self._lock = threading.Lock()
        self._is_initialized = False
        self._data_received_callback = data_received_callback

        self._controlsets = {
            &#39;P300&#39;: {
                &#39;baudrate&#39;: 4800,
                &#39;bytesize&#39;: 8,
                &#39;parity&#39;: &#39;E&#39;,
                &#39;stopbits&#39;: 2,
                &#39;timeout&#39;: 0.5,
                &#39;startbyte&#39;: 0x41,
                &#39;request&#39;: 0x00,
                &#39;response&#39;: 0x01,
                &#39;error&#39;: 0x03,
                &#39;read&#39;: 0x01,
                &#39;write&#39;: 0x02,
                &#39;functioncall&#39;: 0x7,
                &#39;acknowledge&#39;: 0x06,
                &#39;not_initiated&#39;: 0x05,
                &#39;init_error&#39;: 0x15,
                &#39;reset_command&#39;: 0x04,
                &#39;reset_command_response&#39;: 0x05,
                &#39;sync_command&#39;: 0x160000,
                &#39;sync_command_response&#39;: 0x06,
                &#39;command_bytes_read&#39;: 5,
                &#39;command_bytes_write&#39;: 5,
                # init:              send&#39;Reset_Command&#39; receive&#39;Reset_Command_Response&#39; send&#39;Sync_Command&#39;
                # request:           send(&#39;StartByte&#39; &#39;L채nge der Nutzdaten als Anzahl der Bytes zwischen diesem Byte und der Pr체fsumme&#39; &#39;Request&#39; &#39;Read&#39; &#39;addr&#39; &#39;checksum&#39;)
                # request_response:  receive(&#39;Acknowledge&#39; &#39;StartByte&#39; &#39;L채nge der Nutzdaten als Anzahl der Bytes zwischen diesem Byte und der Pr체fsumme&#39; &#39;Response&#39; &#39;Read&#39; &#39;addr&#39; &#39;Anzahl der Bytes des Wertes&#39; &#39;Wert&#39; &#39;checksum&#39;)
            },
            &#39;KW&#39;: {
                &#39;baudrate&#39;: 4800,
                &#39;bytesize&#39;: 8,          # &#39;EIGHTBITS&#39;
                &#39;parity&#39;: &#39;E&#39;,          # &#39;PARITY_EVEN&#39;,
                &#39;stopbits&#39;: 2,          # &#39;STOPBITS_TWO&#39;,
                &#39;timeout&#39;: 1,
                &#39;startbyte&#39;: 0x01,
                &#39;read&#39;: 0xF7,
                &#39;write&#39;: 0xF4,
                &#39;acknowledge&#39;: 0x01,
                &#39;reset_command&#39;: 0x04,
                &#39;not_initiated&#39;: 0x05,
                &#39;write_ack&#39;: 0x00,
            },
        }

        # get protocol or default to P300
        self._viess_proto = kwargs.get(&#39;viess_proto&#39;, &#39;P300&#39;)
        if self._viess_proto not in self._controlsets:
            self._viess_proto = &#39;P300&#39;
        # select controlset for viess_proto
        self._controlset = self._controlsets[self._viess_proto]

        # make sure we have a basic set of parameters for the TCP connection
        self._params = {PLUGIN_ATTR_SERIAL_PORT: &#39;&#39;,
                        PLUGIN_ATTR_SERIAL_BAUD: self._controlset[PLUGIN_ATTR_SERIAL_BAUD],
                        PLUGIN_ATTR_SERIAL_BSIZE: self._controlset[PLUGIN_ATTR_SERIAL_BSIZE],
                        PLUGIN_ATTR_SERIAL_PARITY: self._controlset[PLUGIN_ATTR_SERIAL_PARITY],
                        PLUGIN_ATTR_SERIAL_STOP: self._controlset[PLUGIN_ATTR_SERIAL_STOP],
                        PLUGIN_ATTR_CONN_TIMEOUT: self._controlset[PLUGIN_ATTR_CONN_TIMEOUT],
                        PLUGIN_ATTR_CONN_AUTO_CONN: True,
                        PLUGIN_ATTR_CONN_BINARY: True,
                        PLUGIN_ATTR_CONN_RETRIES: 0,
                        PLUGIN_ATTR_CONN_CYCLE: 3,
                        PLUGIN_ATTR_CB_ON_CONNECT: None,
                        PLUGIN_ATTR_CB_ON_DISCONNECT: None,
                        PLUGIN_ATTR_CONNECTION: CONN_SER_DIR}
        self._params.update(kwargs)

        # check if some of the arguments are usable
        self._set_connection_params()

        # initialize connection
        conn_params = self._params.copy()
        # don&#39;t supply callback, we do only reply-based work
        conn_params.update({PLUGIN_ATTR_CB_ON_CONNECT: None, PLUGIN_ATTR_CB_ON_DISCONNECT: None})
        self._connection = self._params[PLUGIN_ATTR_CONNECTION](device_type, device_id, None, **conn_params)

        # set &#34;method pointers&#34;
        self._send_bytes = self._connection._send_bytes
        self._read_bytes = self._connection._read_bytes

        # tell someone about our actual class
        self.logger.debug(f&#39;protocol initialized from {self.__class__.__name__}&#39;)

    def _close(self):
        self._is_initialized = False
        super()._close()

    def _send_init_on_send(self):
        &#34;&#34;&#34;
        setup the communication protocol prior to sending

        :return: Returns True, if communication was established successfully, False otherwise
        :rtype: bool
        &#34;&#34;&#34;
        if self._viess_proto == &#39;P300&#39; and not self._is_initialized:

            # init procedure is
            # interface: 0x04 (reset)
            #                           device: 0x05 (repeated)
            # interface: 0x160000 (sync)
            #                           device: 0x06 (sync ok)
            # interface: resume communication, periodically send 0x160000 as keepalive if necessary

            RESET = self._int2bytes(self._controlset[&#39;reset_command&#39;], 1)
            NOTINIT = self._int2bytes(self._controlset[&#34;not_initiated&#34;], 1)
            ACK = self._int2bytes(self._controlset[&#39;acknowledge&#39;], 1)
            SYNC = self._int2bytes(self._controlset[&#39;sync_command&#39;], 3)
            ERR = self._int2bytes(self._controlset[&#39;init_error&#39;], 1)

            self.logger.debug(&#39;init communication....&#39;)
            syncsent = False

            self.logger.debug(f&#39;send_bytes: send reset command {RESET}&#39;)
            self._send_bytes(RESET)

            readbyte = self._read_bytes(1)
            self.logger.debug(f&#39;read_bytes: read {readbyte}&#39;)

            for i in range(10):
                if syncsent and readbyte == ACK:
                    self.logger.debug(&#39;device acknowledged initialization&#39;)
                    self._is_initialized = True
                    break
                elif readbyte == NOTINIT:
                    self.logger.debug(f&#39;send_bytes: send sync command {SYNC}&#39;)
                    self._send_bytes(SYNC)
                    syncsent = True
                elif readbyte == ERR:
                    self.logger.error(f&#39;interface reported an error, loop increment {i}&#39;)
                    self.logger.debug(f&#39;send_bytes: send reset command {RESET}&#39;)
                    self._send_bytes(RESET)
                    syncsent = False
                else:   # elif readbyte != b&#39;&#39;:
                    self.logger.debug(f&#39;send_bytes: send reset command {RESET}&#39;)
                    self._send_bytes(RESET)
                    syncsent = False
                readbyte = self._read_bytes(1)
                self.logger.debug(f&#39;read_bytes: read {readbyte}&#39;)

            self.logger.debug(f&#39;communication initialized: {self._is_initialized}&#39;)
            return self._is_initialized

        elif self._viess_proto == &#39;KW&#39;:

            retries = 5
            RESET = self._int2bytes(self._controlset[&#39;reset_command&#39;], 1)
            NOINIT = self._int2bytes(self._controlset[&#39;not_initiated&#39;], 1, signed=False)

            # try to reset communication, especially if previous P300 comms is still open
            self._send_bytes(RESET)

            attempt = 0
            while attempt &lt; retries:
                self.logger.debug(f&#39;starting sync loop - attempt {attempt + 1}/{retries}&#39;)

                self._connection.reset_input_buffer()
                chunk = self._read_bytes(1)
                # enable for &#39;raw&#39; debugging
                # self.logger.debug(f&#39;sync loop - got {self._bytes2hexstring(chunk)}&#39;)
                if chunk == NOINIT:
                    self.logger.debug(&#39;got sync, commencing command send&#39;)
                    self._is_initialized = True
                    return True
                sleep(.8)
                attempt = attempt + 1
            self.logger.error(f&#39;sync not acquired after {attempt} attempts&#39;)
            self._close()
            return False

        return True

    def _send(self, data_dict):
        &#34;&#34;&#34;
        send data. data_dict needs to contain the following information:

        data_dict[&#39;payload&#39;]: address from/to which to read/write (hex, str)
        data_dict[&#39;data&#39;][&#39;len&#39;]: length of command to send
        data_dict[&#39;data&#39;][&#39;value&#39;]: value bytes to write, None if reading

        :param data_dict: send data
        :param read_response: KW only: read response value (True) or only return status byte
        :type data_dict: dict
        :type read_response: bool
        :return: Response packet (bytearray) if no error occured, None otherwise
        &#34;&#34;&#34;
        (packet, responselen) = self._build_payload(data_dict)

        # send payload
        self._lock.acquire()
        try:
            self._send_bytes(packet)
            self.logger.debug(f&#39;successfully sent packet {self._bytes2hexstring(packet)}&#39;)

            # receive response
            response_packet = bytearray()
            self.logger.debug(f&#39;trying to receive {responselen} bytes of the response&#39;)
            chunk = self._read_bytes(responselen)
            if self._viess_proto == &#39;P300&#39;:
                self.logger.debug(f&#39;received {len(chunk)} bytes chunk of response as hexstring {self._bytes2hexstring(chunk)} and as bytes {chunk}&#39;)
                if len(chunk) != 0:
                    if chunk[:1] == self._int2bytes(self._controlset[&#39;error&#39;], 1):
                        self.logger.error(f&#39;interface returned error, response was {chunk}&#39;)
                    elif len(chunk) == 1 and chunk[:1] == self._int2bytes(self._controlset[&#39;not_initiated&#39;], 1):
                        self.logger.error(&#39;received invalid chunk, connection not initialized, forcing re-initialize...&#39;)
                        self._initialized = False
                    elif chunk[:1] != self._int2bytes(self._controlset[&#39;acknowledge&#39;], 1):
                        self.logger.error(f&#39;received invalid chunk, not starting with ACK, response was {chunk}&#39;)
                        self._error_count += 1
                        if self._error_count &gt;= 5:
                            self.logger.warning(&#39;encountered 5 invalid chunks in sequence, maybe communication was lost, forcing re-initialize&#39;)
                            self._initialized = False
                    else:
                        response_packet.extend(chunk)
                        self._error_count = 0
                        return self._parse_response(response_packet)
                else:
                    self.logger.error(f&#39;received 0 bytes chunk - ignoring response_packet, chunk was {chunk}&#39;)
            elif self._protocol == &#39;KW&#39;:
                self.logger.debug(f&#39;received {len(chunk)} bytes chunk of response as hexstring {self._bytes2hexstring(chunk)} and as bytes {chunk}&#39;)
                if len(chunk) != 0:
                    response_packet.extend(chunk)
                    return self._parse_response(response_packet, data_dict[&#39;data&#39;][&#39;value&#39;] is None)
                else:
                    self.logger.error(&#39;received 0 bytes chunk - this probably is a communication error, possibly a wrong datapoint address?&#39;)
        except IOError as e:
            self.logger.error(f&#39;send_command_packet failed with IO error, trying to reconnect. Error was: {e}&#39;)
            self._close()
        except Exception as e:
            self.logger.error(f&#39;send_command_packet failed with error: {e}&#39;)
        finally:
            try:
                self._lock.release()
            except RuntimeError:
                pass

        # if we didn&#39;t return with data earlier, we hit an error. Act accordingly
        return None

    def _parse_response(self, response, read_response=True):
        &#34;&#34;&#34;
        Process device response data, try to parse type and value

        :param response: Data received from device
        :type response: bytearray
        :param read_response: True if command was read command and value is expected, False if only status byte is expected (only needed for KW protocol)
        :type read_response: bool
        :return: tuple of (parsed response value, commandcode) or None if error
        &#34;&#34;&#34;
        if self._viess_proto == &#39;P300&#39;:

            # A read_response telegram looks like this: ACK (1 byte), startbyte (1 byte), data length in bytes (1 byte), request/response (1 byte), read/write (1 byte), addr (2 byte), amount of valuebytes (1 byte), value (bytes as per last byte), checksum (1 byte)
            # A write_response telegram looks like this: ACK (1 byte), startbyte (1 byte), data length in bytes (1 byte), request/response (1 byte), read/write (1 byte), addr (2 byte), amount of bytes written (1 byte), checksum (1 byte)

            # Validate checksum
            checksum = self._calc_checksum(response[1:len(response) - 1])  # first, cut first byte (ACK) and last byte (checksum) and then calculate checksum
            received_checksum = response[len(response) - 1]
            if received_checksum != checksum:
                self.logger.error(f&#39;calculated checksum {checksum} does not match received checksum of {received_checksum}! Ignoring reponse&#39;)
                return None

            # Extract command/address, valuebytes and valuebytecount out of response
            responsetypecode = response[3]  # 0x00 = query, 0x01 = reply, 0x03 = error
            responsedatacode = response[4]  # 0x01 = ReadData, 0x02 = WriteData, 0x07 = Function Call
            valuebytecount = response[7]

            # Extract databytes out of response
            rawdatabytes = bytearray()
            rawdatabytes.extend(response[8:8 + (valuebytecount)])
        elif self._protocol == &#39;KW&#39;:

            # imitate P300 response code data for easier combined handling afterwards
            # a read_response telegram consists only of the value bytes
            # a write_response telegram is 0x00 for OK, 0xXX for error
            responsetypecode = 1
            valuebytecount = len(response)
            rawdatabytes = response

            if read_response:
                # value response to read request, error detection by empty = no response
                responsedatacode = 1
                if len(rawdatabytes) == 0:
                    # error, no answer means wrong address (?)
                    responsetypecode = 3
            else:
                # status response to write request
                responsedatacode = 2
                if (len(rawdatabytes) == 1 and rawdatabytes[0] != 0) or len(rawdatabytes) == 0:
                    # error if status reply is not 0x00
                    responsetypecode = 3

        self.logger.debug(f&#39;Response decoded to: responsedatacode: {responsedatacode}, valuebytecount: {valuebytecount}, responsetypecode: {responsetypecode}&#39;)

        if responsetypecode == 3:
            raise ValueError(f&#39;error on reading reply {rawdatabytes}&#39;)

        if responsedatacode == 2:
            self.logger.debug(&#39;write request successful&#39;)
            return None

        self.logger.debug(f&#39;read request successful, read bytes {rawdatabytes}&#39;)
        return rawdatabytes

    def _build_payload(self, data_dict):
        &#34;&#34;&#34;
        create payload from data_dict. Necessary data:

        data_dict[&#39;payload&#39;]: address from/to which to read/write (hex, str)
        data_dict[&#39;data&#39;][&#39;len&#39;]: length of command to send
        data_dict[&#39;data&#39;][&#39;value&#39;]: value bytes to write, None if reading
        data_dict[&#39;data&#39;][&#39;kwseq&#39;]: packet is follow-up packet in KW

        :param data_dict: data to convert
        :type data_dict: dict
        :return: (packet, responselen)
        :rtype: tuple
        &#34;&#34;&#34;
        try:
            addr = data_dict[&#39;payload&#39;].lower()
            cmdlen = data_dict[&#39;data&#39;][&#39;len&#39;]
            valuebytes = data_dict[&#39;data&#39;][&#39;value&#39;]
            KWFollowUp = data_dict[&#39;data&#39;].get(&#39;kwseq&#39;, False)
        except Exception as e:
            raise ValueError(f&#39;data_dict {data_dict} not usable, data not sent. Error was: {e}&#39;)

        write = valuebytes is not None

        # build payload
        if write:
            payloadlength = int(self._controlset.get(&#39;command_bytes_write&#39;, 0)) + int(valuebytes)
            self.logger.debug(f&#39;Payload length is: {payloadlength} bytes&#39;)

        packet = bytearray()
        if not KWFollowUp:
            packet.extend(self._int2bytes(self._controlset[&#39;startbyte&#39;], 1))
        if self._viess_proto == &#39;P300&#39;:
            if write:
                packet.extend(self._int2bytes(payloadlength, 1))
            else:
                packet.extend(self._int2bytes(self._controlset[&#39;command_bytes_read&#39;], 1))
            packet.extend(self._int2bytes(self._controlset[&#39;request&#39;], 1))

        if write:
            packet.extend(self._int2bytes(self._controlset[&#39;write&#39;], 1))
        else:
            packet.extend(self._int2bytes(self._controlset[&#39;read&#39;], 1))
        packet.extend(bytes.fromhex(addr))
        packet.extend(self._int2bytes(cmdlen, 1))
        if write:
            packet.extend(valuebytes)
        if self._viess_proto == &#39;P300&#39;:
            packet.extend(self._int2bytes(self._calc_checksum(packet), 1))

        if self._viess_proto == &#39;P300&#39;:
            responselen = int(self._controlset[&#39;command_bytes_read&#39;]) + 4 + (0 if write else int(cmdlen))
        else:
            responselen = 1 if write else int(cmdlen)

        if write:
            self.logger.debug(f&#39;created payload to be sent as hexstring: {self._bytes2hexstring(packet)} and as bytes: {packet} with value {self._bytes2hexstring(valuebytes)})&#39;)
        else:
            self.logger.debug(f&#39;created payload to be sent as hexstring: {self._bytes2hexstring(packet)} and as bytes: {packet}&#39;)

        return (packet, responselen)

    @staticmethod
    def _calc_checksum(packet):
        &#34;&#34;&#34;
        Calculate checksum for P300 protocol packets

        :parameter packet: Data packet for which to calculate checksum
        :type packet: bytearray
        :return: Calculated checksum
        :rtype: int
        &#34;&#34;&#34;
        checksum = 0
        if len(packet) &gt; 0:
            if packet[:1] == b&#39;\x41&#39;:
                packet = packet[1:]
                checksum = sum(packet)
                checksum = checksum - int(checksum / 256) * 256
        return checksum

    @staticmethod
    def _int2bytes(value, length, signed=False):
        &#34;&#34;&#34;
        Convert value to bytearray with respect to defined length and sign format.
        Value exceeding limit set by length and sign will be truncated

        :parameter value: Value to convert
        :type value: int
        :parameter length: number of bytes to create
        :type length: int
        :parameter signed: True if result should be a signed int, False for unsigned
        :type signed: bool
        :return: Converted value
        :rtype: bytearray
        &#34;&#34;&#34;
        value = value % (2 ** (length * 8))
        return value.to_bytes(length, byteorder=&#39;big&#39;, signed=signed)

    @staticmethod
    def _bytes2int(rawbytes, signed):
        &#34;&#34;&#34;
        Convert bytearray to value with respect to sign format

        :parameter rawbytes: Bytes to convert
        :type value: bytearray
        :parameter signed: True if result should be a signed int, False for unsigned
        :type signed: bool
        :return: Converted value
        :rtype: int
        &#34;&#34;&#34;
        return int.from_bytes(rawbytes, byteorder=&#39;little&#39;, signed=signed)

    @staticmethod
    def _bytes2hexstring(bytesvalue):
        &#34;&#34;&#34;
        Create hex-formatted string from bytearray
        :param bytesvalue: Bytes to convert
        :type bytesvalue: bytearray
        :return: Converted hex string
        :rtype: str
        &#34;&#34;&#34;
        return &#39;&#39;.join(f&#39;{c:02x}&#39; for c in bytesvalue)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Protocol.MD_Protocol" href="#multidevice.MD_Protocol.MD_Protocol">MD_Protocol</a></li>
<li><a title="multidevice.MD_Connection.MD_Connection" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection">MD_Connection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Protocol.MD_Protocol" href="#multidevice.MD_Protocol.MD_Protocol">MD_Protocol</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.close" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.close">close</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.connected" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.connected">connected</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.on_connect" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_connect">on_connect</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.on_data_received" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_data_received">on_data_received</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.on_disconnect" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.on_disconnect">on_disconnect</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.open" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.open">open</a></code></li>
<li><code><a title="multidevice.MD_Protocol.MD_Protocol.send" href="MD_Connection.html#multidevice.MD_Connection.MD_Connection.send">send</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multidevice" href="index.html">multidevice</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multidevice.MD_Protocol.MD_Protocol" href="#multidevice.MD_Protocol.MD_Protocol">MD_Protocol</a></code></h4>
</li>
<li>
<h4><code><a title="multidevice.MD_Protocol.MD_Protocol_Jsonrpc" href="#multidevice.MD_Protocol.MD_Protocol_Jsonrpc">MD_Protocol_Jsonrpc</a></code></h4>
</li>
<li>
<h4><code><a title="multidevice.MD_Protocol.MD_Protocol_Viessmann" href="#multidevice.MD_Protocol.MD_Protocol_Viessmann">MD_Protocol_Viessmann</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>